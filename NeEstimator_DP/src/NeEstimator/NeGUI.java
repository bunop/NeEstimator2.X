/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package NeEstimator;

import java.awt.Component;
import java.awt.Container;
import java.awt.Dimension;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.io.*;
import java.text.DecimalFormat;
import javax.swing.*;
import java.lang.Math;
import java.awt.Desktop;     // DP Added 03 May 2013




/**
 *
 * @author Chi.Do
 */
public class NeGUI extends javax.swing.JFrame {

    public Desktop desktop = Desktop.getDesktop();     // DP Added 03 May 2013

    /**
     * Creates new form NeGUI
     */
    public NeGUI() {
        initComponents();
        getOSName();
// In Linux, it may happen that when jar file is double clicked,
// it is run from the home directory of the user, so getPath will assign
// currPath as the directory where the jar file is located.
// Actually, the code in getPath should be OK for Windows and Mac too,
// so the statement
//        currPath = getPath();
// should work for all.
// Using the statement above for Windows and Mac prevents the error
// when this jar file is run from command line opened at the folder that
// is not the folder containing the jar file.

// To get rid of "if ... else", have only one slash at the beginning of
// the next (empty) line, two slashes to keep it
/*
        if (osName.equals("Windows") || osName.equals("Mac"))
        // jar file is run by double click,
        // and the current directory is where the jar file is located.
            currPath = currDirectory();
        else
//*/
            currPath = getPath();
        initialize ();
        getCmdHeader();
        Dimension frSize = this.getSize();
//System.out.println("Width = " + frSize.getWidth());
//System.out.println("Height = " + frSize.getHeight()+"\n");

// Resizing operation may be restricted if the user tries to resize window
// below the minimumSize value. This behaviour is platform-dependent.
        this.setMinimumSize(frSize);
// The rest are for checking sizes and methods involving size.
/* One slash at the start of this line to comment out; 2 slashes to activate
Dimension maxFormSize = new Dimension();
maxFormSize.setSize(2*frSize.getWidth(), frSize.getHeight());
// seems to have no effect when resizing the window:
this.setMaximumSize(maxFormSize);
//this.setMaximumSize(frSize);

System.out.println("Width = " + frSize.getWidth());
System.out.println("Height = " + frSize.getHeight()+"\n");
System.out.println("Name = " + this.getName());
System.out.println("MaximumSize = " + this.getMaximumSize());
System.out.println("MinimumSize = " + this.getMinimumSize());
System.out.println("PreferredSize = " + this.getPreferredSize());
System.out.println("Size = " + this.getSize());
//*/
        // get image for "About" menu. If no image file, hasImage = false
        hasImage = getIcon();
// -----------------------------
// Modification at this version:
// -----------------------------
// May 2013: Move population range from collectInfo to collectOption,
// and move Mating Model from collectOption to collectInfo.
// Then change method hasOption() to reflect when option file should be
// created for command line.
// The code of program Ne2 should be changed accordingly.
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        buttonGroup1 = new javax.swing.ButtonGroup();
        buttonGroup2 = new javax.swing.ButtonGroup();
        buttonGroup3 = new javax.swing.ButtonGroup();
        jPanelInput = new javax.swing.JPanel();
        jLabel1 = new javax.swing.JLabel();
        jTextInpFolder = new javax.swing.JTextField();
        jButtonInpFolder = new javax.swing.JButton();
        jLabel2 = new javax.swing.JLabel();
        jComboBoxFile = new javax.swing.JComboBox();
        jLabel3 = new javax.swing.JLabel();
        jRadioButtonGen = new javax.swing.JRadioButton();
        jRadioButtonFstat = new javax.swing.JRadioButton();
        jCheckFileType = new javax.swing.JCheckBox();
        jTextShow = new javax.swing.JTextField();
        jButtonInfo = new javax.swing.JButton();
        jLabel7 = new javax.swing.JLabel();
        jPanelMethod = new javax.swing.JPanel();
        jCheckLD = new javax.swing.JCheckBox();
        jCheckHet = new javax.swing.JCheckBox();
        jCheckCoan = new javax.swing.JCheckBox();
        jCheckTemp = new javax.swing.JCheckBox();
        jTextTemp = new javax.swing.JTextField();
        jRadioButtonRan = new javax.swing.JRadioButton();
        jRadioButtonMono = new javax.swing.JRadioButton();
        jButtonTemp = new javax.swing.JButton();
        jButtonTpMethod = new javax.swing.JButton();
        jLabelPlan = new javax.swing.JLabel();
        jLabel10 = new javax.swing.JLabel();
        jPanelOutput = new javax.swing.JPanel();
        jLabel4 = new javax.swing.JLabel();
        jTextOutFolder = new javax.swing.JTextField();
        jLabel5 = new javax.swing.JLabel();
        jTextOutFile = new javax.swing.JTextField();
        jButtonOutFolder = new javax.swing.JButton();
        jCheckName = new javax.swing.JCheckBox();
        jCheckAppend = new javax.swing.JCheckBox();
        jLabel6 = new javax.swing.JLabel();
        jCheckXtraOut = new javax.swing.JCheckBox();
        jTextFieldxLD = new javax.swing.JTextField();
        jCheckBurr = new javax.swing.JCheckBox();
        jTextBurrOut = new javax.swing.JTextField();
        jLabelBur1 = new javax.swing.JLabel();
        jTextBurr = new javax.swing.JTextField();
        jLabelBur2 = new javax.swing.JLabel();
        jCheckLocOut = new javax.swing.JCheckBox();
        jTextLocOut = new javax.swing.JTextField();
        jLabelLoc1 = new javax.swing.JLabel();
        jTextLoc = new javax.swing.JTextField();
        jLabelLoc2 = new javax.swing.JLabel();
        jButtonExit = new javax.swing.JButton();
        jLabelMisDat = new javax.swing.JLabel();
        jTextMisDat = new javax.swing.JTextField();
        jLabel8 = new javax.swing.JLabel();
        jButtonParamFile = new javax.swing.JButton();
        jTextFieldxHet = new javax.swing.JTextField();
        jTextFieldxCoan = new javax.swing.JTextField();
        jTextFieldxTemp = new javax.swing.JTextField();
        jLabelBur3 = new javax.swing.JLabel();
        jTextBCrit = new javax.swing.JTextField();
        jTextXCrit = new javax.swing.JTextField();
        jLabelxOut2 = new javax.swing.JLabel();
        jLabelxOut1 = new javax.swing.JLabel();
        jLabelxOut3 = new javax.swing.JLabel();
        jCheckTab = new javax.swing.JCheckBox();
        jPanelPcrit = new javax.swing.JPanel();
        listPcrit = new java.awt.List();
        jTextPcrit = new javax.swing.JTextField();
        jButtonAdd = new javax.swing.JButton();
        jLabelP1 = new javax.swing.JLabel();
        jLabelP2 = new javax.swing.JLabel();
        jButtonDel = new javax.swing.JButton();
        jCheckPcrit0 = new javax.swing.JCheckBox();
        jPanelOption = new javax.swing.JPanel();
        jCheckPop = new javax.swing.JCheckBox();
        jCheckSamp = new javax.swing.JCheckBox();
        jCheckLoc = new javax.swing.JCheckBox();
        jRadioButtonRange = new javax.swing.JRadioButton();
        jRadioButtonDel = new javax.swing.JRadioButton();
        jTextPop = new javax.swing.JTextField();
        jTextSamp = new javax.swing.JTextField();
        jTextRange = new javax.swing.JTextField();
        jTextLocDel = new javax.swing.JTextField();
        jCheckBoxCI = new javax.swing.JCheckBox();
        jButtonLoci = new javax.swing.JButton();
        jButtonRun = new javax.swing.JButton();
        jMenuBar1 = new javax.swing.JMenuBar();
        jMenuFile = new javax.swing.JMenu();
        jMenuInput = new javax.swing.JMenuItem();
        jSeparator1 = new javax.swing.JPopupMenu.Separator();
        jMenuParam = new javax.swing.JMenuItem();
        jMenuSave = new javax.swing.JMenuItem();
        jMenuExit = new javax.swing.JMenuItem();
        jMenuAction = new javax.swing.JMenu();
        jMenuRun = new javax.swing.JMenuItem();
        jSeparator2 = new javax.swing.JPopupMenu.Separator();
        jMenuTerm = new javax.swing.JMenuItem();
        jMenu2 = new javax.swing.JMenu();
        jMenuAbout = new javax.swing.JMenuItem();
        jSeparator3 = new javax.swing.JPopupMenu.Separator();
        jMenuHelpFile = new javax.swing.JMenuItem();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("Ne Estimator");

        jPanelInput.setBorder(javax.swing.BorderFactory.createTitledBorder(null, "INPUT", javax.swing.border.TitledBorder.DEFAULT_JUSTIFICATION, javax.swing.border.TitledBorder.DEFAULT_POSITION, new java.awt.Font("Academy", 1, 12))); // NOI18N

        jLabel1.setText("Directory:");

        jButtonInpFolder.setText("Browse");
        jButtonInpFolder.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonInpFolderActionPerformed(evt);
            }
        });

        jLabel2.setText("Choose File:");

        jComboBoxFile.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "Item 1", "Item 2", "Item 3", "Item 4" }));
        jComboBoxFile.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                jComboBoxFileMouseClicked(evt);
            }
            public void mouseEntered(java.awt.event.MouseEvent evt) {
                jComboBoxFileMouseEntered(evt);
            }
        });
        jComboBoxFile.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jComboBoxFileActionPerformed(evt);
            }
        });
        jComboBoxFile.addFocusListener(new java.awt.event.FocusAdapter() {
            public void focusGained(java.awt.event.FocusEvent evt) {
                jComboBoxFileFocusGained(evt);
            }
        });

        jLabel3.setText("Data Format:");

        buttonGroup1.add(jRadioButtonGen);
        jRadioButtonGen.setText("GENEPOP");

        buttonGroup1.add(jRadioButtonFstat);
        jRadioButtonFstat.setText("FSTAT");

        jCheckFileType.setText("List Files with extensions TXT, GEN, DAT only");
        jCheckFileType.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jCheckFileTypeActionPerformed(evt);
            }
        });

        jTextShow.setBackground(new java.awt.Color(255, 255, 225));

        jButtonInfo.setText("Info");
        jButtonInfo.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonInfoActionPerformed(evt);
            }
        });

        jLabel7.setText("Line 1:");

        javax.swing.GroupLayout jPanelInputLayout = new javax.swing.GroupLayout(jPanelInput);
        jPanelInput.setLayout(jPanelInputLayout);
        jPanelInputLayout.setHorizontalGroup(
            jPanelInputLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanelInputLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanelInputLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addComponent(jLabel1)
                    .addComponent(jLabel2)
                    .addComponent(jLabel3)
                    .addComponent(jLabel7))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addGroup(jPanelInputLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addGroup(javax.swing.GroupLayout.Alignment.LEADING, jPanelInputLayout.createSequentialGroup()
                        .addGroup(jPanelInputLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(jPanelInputLayout.createSequentialGroup()
                                .addComponent(jComboBoxFile, javax.swing.GroupLayout.PREFERRED_SIZE, 253, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(jCheckFileType))
                            .addGroup(jPanelInputLayout.createSequentialGroup()
                                .addGap(10, 10, 10)
                                .addComponent(jRadioButtonGen)
                                .addGap(46, 46, 46)
                                .addComponent(jRadioButtonFstat)))
                        .addContainerGap())
                    .addGroup(jPanelInputLayout.createSequentialGroup()
                        .addGroup(jPanelInputLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jTextShow)
                            .addComponent(jTextInpFolder))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(jPanelInputLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jButtonInpFolder, javax.swing.GroupLayout.Alignment.TRAILING)
                            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanelInputLayout.createSequentialGroup()
                                .addComponent(jButtonInfo, javax.swing.GroupLayout.PREFERRED_SIZE, 67, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addGap(2, 2, 2))))))
        );

        jPanelInputLayout.linkSize(javax.swing.SwingConstants.HORIZONTAL, new java.awt.Component[] {jButtonInfo, jButtonInpFolder});

        jPanelInputLayout.setVerticalGroup(
            jPanelInputLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanelInputLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanelInputLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel1)
                    .addComponent(jTextInpFolder, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jButtonInpFolder))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanelInputLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel2)
                    .addComponent(jComboBoxFile, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jCheckFileType))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addGroup(jPanelInputLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel3)
                    .addComponent(jRadioButtonGen)
                    .addComponent(jRadioButtonFstat))
                .addGap(18, 18, 18)
                .addGroup(jPanelInputLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jTextShow, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jButtonInfo)
                    .addComponent(jLabel7))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        jPanelMethod.setBorder(javax.swing.BorderFactory.createTitledBorder(null, "Methods", javax.swing.border.TitledBorder.DEFAULT_JUSTIFICATION, javax.swing.border.TitledBorder.DEFAULT_POSITION, new java.awt.Font("Times New Roman", 1, 12))); // NOI18N

        jCheckLD.setText("Linkage Disequilibrium - Model:");
        jCheckLD.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jCheckLDActionPerformed(evt);
            }
        });

        jCheckHet.setText("Heterozygote Excess");
        jCheckHet.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jCheckHetActionPerformed(evt);
            }
        });

        jCheckCoan.setText("Molecular Coancestry");
        jCheckCoan.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jCheckCoanActionPerformed(evt);
            }
        });

        jCheckTemp.setText("Temporal,");
        jCheckTemp.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jCheckTempActionPerformed(evt);
            }
        });

        jTextTemp.setFont(new java.awt.Font("Tahoma", 1, 11)); // NOI18N
        jTextTemp.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyPressed(java.awt.event.KeyEvent evt) {
                jTextTempKeyPressed(evt);
            }
            public void keyReleased(java.awt.event.KeyEvent evt) {
                jTextTempKeyReleased(evt);
            }
        });

        buttonGroup3.add(jRadioButtonRan);
        jRadioButtonRan.setSelected(true);
        jRadioButtonRan.setText("Random Mating");
        jRadioButtonRan.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jRadioButtonRanActionPerformed(evt);
            }
        });

        buttonGroup3.add(jRadioButtonMono);
        jRadioButtonMono.setText("Monogamy");
        jRadioButtonMono.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jRadioButtonMonoActionPerformed(evt);
            }
        });

        jButtonTemp.setText("?");
        jButtonTemp.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonTempActionPerformed(evt);
            }
        });

        jButtonTpMethod.setText("More Choices");
        jButtonTpMethod.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonTpMethodActionPerformed(evt);
            }
        });

        jLabelPlan.setFont(new java.awt.Font("Tahoma", 1, 12)); // NOI18N
        jLabelPlan.setText("II");

        jLabel10.setText("Plan");

        javax.swing.GroupLayout jPanelMethodLayout = new javax.swing.GroupLayout(jPanelMethod);
        jPanelMethod.setLayout(jPanelMethodLayout);
        jPanelMethodLayout.setHorizontalGroup(
            jPanelMethodLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanelMethodLayout.createSequentialGroup()
                .addGroup(jPanelMethodLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanelMethodLayout.createSequentialGroup()
                        .addComponent(jTextTemp)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jButtonTemp))
                    .addGroup(jPanelMethodLayout.createSequentialGroup()
                        .addGap(1, 1, 1)
                        .addGroup(jPanelMethodLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jCheckHet)
                            .addComponent(jCheckLD)
                            .addGroup(jPanelMethodLayout.createSequentialGroup()
                                .addGap(13, 13, 13)
                                .addComponent(jRadioButtonRan)
                                .addGap(18, 18, 18)
                                .addComponent(jRadioButtonMono))
                            .addComponent(jCheckCoan)
                            .addGroup(jPanelMethodLayout.createSequentialGroup()
                                .addComponent(jCheckTemp, javax.swing.GroupLayout.PREFERRED_SIZE, 85, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(jLabel10)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(jLabelPlan)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                                .addComponent(jButtonTpMethod)))))
                .addContainerGap())
        );
        jPanelMethodLayout.setVerticalGroup(
            jPanelMethodLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanelMethodLayout.createSequentialGroup()
                .addComponent(jCheckLD)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanelMethodLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jRadioButtonRan)
                    .addComponent(jRadioButtonMono))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jCheckHet)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jCheckCoan)
                .addGap(1, 1, 1)
                .addGroup(jPanelMethodLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jCheckTemp)
                    .addComponent(jLabelPlan)
                    .addComponent(jButtonTpMethod, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(jLabel10))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanelMethodLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jButtonTemp)
                    .addComponent(jTextTemp, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)))
        );

        jPanelOutput.setBorder(javax.swing.BorderFactory.createTitledBorder(null, "OUTPUT", javax.swing.border.TitledBorder.DEFAULT_JUSTIFICATION, javax.swing.border.TitledBorder.DEFAULT_POSITION, new java.awt.Font("Academy", 1, 12))); // NOI18N

        jLabel4.setText("Directory:");

        jLabel5.setText("File Name:");

        jTextOutFile.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jTextOutFileActionPerformed(evt);
            }
        });
        jTextOutFile.addFocusListener(new java.awt.event.FocusAdapter() {
            public void focusLost(java.awt.event.FocusEvent evt) {
                jTextOutFileFocusLost(evt);
            }
        });
        jTextOutFile.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyPressed(java.awt.event.KeyEvent evt) {
                jTextOutFileKeyPressed(evt);
            }
            public void keyReleased(java.awt.event.KeyEvent evt) {
                jTextOutFileKeyReleased(evt);
            }
        });

        jButtonOutFolder.setText("Browse");
        jButtonOutFolder.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonOutFolderActionPerformed(evt);
            }
        });

        jCheckName.setText("Use Default Name (uncheck to edit)");
        jCheckName.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jCheckNameActionPerformed(evt);
            }
        });

        jCheckAppend.setText("Main and Tabular-Format Output Files to be appended");
        jCheckAppend.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jCheckAppendActionPerformed(evt);
            }
        });

        jLabel6.setFont(new java.awt.Font("Tahoma", 1, 11)); // NOI18N
        jLabel6.setText("ADDITIONAL  OUTPUT  FILES:");

        jCheckXtraOut.setText(" Output File(s) in tabular format,");
        jCheckXtraOut.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jCheckXtraOutActionPerformed(evt);
            }
        });

        jTextFieldxLD.setBackground(new java.awt.Color(216, 228, 248));

        jCheckBurr.setText("Output File for Burrow coefficients in Linkage Disequlibrium method.  Name:");
        jCheckBurr.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jCheckBurrActionPerformed(evt);
            }
        });

        jTextBurrOut.setBackground(new java.awt.Color(216, 228, 248));

        jLabelBur1.setText("Only for populations in range:");

        jTextBurr.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jTextBurrActionPerformed(evt);
            }
        });
        jTextBurr.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyPressed(java.awt.event.KeyEvent evt) {
                jTextBurrKeyPressed(evt);
            }
            public void keyReleased(java.awt.event.KeyEvent evt) {
                jTextBurrKeyReleased(evt);
            }
        });

        jLabelBur2.setText("(max = 50),   and only for the top");

        jCheckLocOut.setText("Output File for Frequency Data for all loci- details up to 100 loci.  Name:");
        jCheckLocOut.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jCheckLocOutActionPerformed(evt);
            }
        });

        jTextLocOut.setBackground(new java.awt.Color(216, 228, 248));

        jLabelLoc1.setText("Only for populations in range:");

        jTextLoc.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyPressed(java.awt.event.KeyEvent evt) {
                jTextLocKeyPressed(evt);
            }
            public void keyReleased(java.awt.event.KeyEvent evt) {
                jTextLocKeyReleased(evt);
            }
        });

        jLabelLoc2.setText("(max = 50)");

        jButtonExit.setText("Save Settings and Exit");
        jButtonExit.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonExitActionPerformed(evt);
            }
        });

        jLabelMisDat.setText("Missing data, if any, will be written to:");

        jTextMisDat.setBackground(new java.awt.Color(216, 228, 248));

        jLabel8.setText("(Names are preset, not editable)");

        jButtonParamFile.setText("Create Parameter Files");
        jButtonParamFile.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonParamFileActionPerformed(evt);
            }
        });

        jLabelBur3.setText("critical value(s)");

        jTextBCrit.setText("1");
        jTextBCrit.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jTextBCritActionPerformed(evt);
            }
        });
        jTextBCrit.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyPressed(java.awt.event.KeyEvent evt) {
                jTextBCritKeyPressed(evt);
            }
            public void keyReleased(java.awt.event.KeyEvent evt) {
                jTextBCritKeyReleased(evt);
            }
        });

        jTextXCrit.setText("1");
        jTextXCrit.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyPressed(java.awt.event.KeyEvent evt) {
                jTextXCritKeyPressed(evt);
            }
            public void keyReleased(java.awt.event.KeyEvent evt) {
                jTextXCritKeyReleased(evt);
            }
        });

        jLabelxOut2.setText("critical value(s).");

        jLabelxOut1.setText("for the top");

        jLabelxOut3.setText("Name(s):");

        jCheckTab.setText("With Tab delimiter in the format");

        javax.swing.GroupLayout jPanelOutputLayout = new javax.swing.GroupLayout(jPanelOutput);
        jPanelOutput.setLayout(jPanelOutputLayout);
        jPanelOutputLayout.setHorizontalGroup(
            jPanelOutputLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanelOutputLayout.createSequentialGroup()
                .addGap(20, 20, 20)
                .addGroup(jPanelOutputLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jLabel5, javax.swing.GroupLayout.Alignment.TRAILING)
                    .addComponent(jLabel4, javax.swing.GroupLayout.Alignment.TRAILING))
                .addGap(10, 10, 10)
                .addGroup(jPanelOutputLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanelOutputLayout.createSequentialGroup()
                        .addComponent(jTextOutFolder)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jButtonOutFolder))
                    .addGroup(jPanelOutputLayout.createSequentialGroup()
                        .addComponent(jTextOutFile, javax.swing.GroupLayout.PREFERRED_SIZE, 243, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(jPanelOutputLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jCheckAppend)
                            .addComponent(jCheckName)))))
            .addGroup(jPanelOutputLayout.createSequentialGroup()
                .addGroup(jPanelOutputLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addGroup(jPanelOutputLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                        .addGroup(jPanelOutputLayout.createSequentialGroup()
                            .addGap(202, 202, 202)
                            .addGroup(jPanelOutputLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                                .addComponent(jButtonExit, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.PREFERRED_SIZE, 175, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addComponent(jButtonParamFile, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.PREFERRED_SIZE, 175, javax.swing.GroupLayout.PREFERRED_SIZE)))
                        .addGroup(javax.swing.GroupLayout.Alignment.LEADING, jPanelOutputLayout.createSequentialGroup()
                            .addGap(452, 452, 452)
                            .addComponent(jTextLocOut, javax.swing.GroupLayout.PREFERRED_SIZE, 188, javax.swing.GroupLayout.PREFERRED_SIZE)))
                    .addGroup(jPanelOutputLayout.createSequentialGroup()
                        .addGap(10, 10, 10)
                        .addGroup(jPanelOutputLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(jPanelOutputLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                                .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanelOutputLayout.createSequentialGroup()
                                    .addComponent(jTextFieldxHet, javax.swing.GroupLayout.PREFERRED_SIZE, 219, javax.swing.GroupLayout.PREFERRED_SIZE)
                                    .addGap(8, 8, 8)
                                    .addComponent(jTextFieldxCoan, javax.swing.GroupLayout.PREFERRED_SIZE, 204, javax.swing.GroupLayout.PREFERRED_SIZE)
                                    .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                    .addComponent(jTextFieldxTemp, javax.swing.GroupLayout.PREFERRED_SIZE, 193, javax.swing.GroupLayout.PREFERRED_SIZE))
                                .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanelOutputLayout.createSequentialGroup()
                                    .addGroup(jPanelOutputLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                        .addGroup(jPanelOutputLayout.createSequentialGroup()
                                            .addComponent(jCheckXtraOut)
                                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                            .addComponent(jLabelxOut1)
                                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                            .addComponent(jTextXCrit, javax.swing.GroupLayout.PREFERRED_SIZE, 21, javax.swing.GroupLayout.PREFERRED_SIZE)
                                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                            .addComponent(jLabelxOut2)
                                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                            .addComponent(jLabelxOut3))
                                        .addGroup(jPanelOutputLayout.createSequentialGroup()
                                            .addComponent(jLabel6)
                                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                            .addComponent(jLabel8)))
                                    .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                    .addGroup(jPanelOutputLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                        .addComponent(jCheckTab)
                                        .addComponent(jTextFieldxLD, javax.swing.GroupLayout.PREFERRED_SIZE, 194, javax.swing.GroupLayout.PREFERRED_SIZE)))
                                .addComponent(jCheckLocOut)
                                .addGroup(jPanelOutputLayout.createSequentialGroup()
                                    .addGap(21, 21, 21)
                                    .addComponent(jLabelBur1)
                                    .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                    .addComponent(jTextBurr, javax.swing.GroupLayout.PREFERRED_SIZE, 70, javax.swing.GroupLayout.PREFERRED_SIZE)
                                    .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                    .addComponent(jLabelBur2)
                                    .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                    .addComponent(jTextBCrit, javax.swing.GroupLayout.PREFERRED_SIZE, 25, javax.swing.GroupLayout.PREFERRED_SIZE)
                                    .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                                    .addComponent(jLabelBur3))
                                .addGroup(jPanelOutputLayout.createSequentialGroup()
                                    .addComponent(jCheckBurr)
                                    .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                    .addComponent(jTextBurrOut, javax.swing.GroupLayout.PREFERRED_SIZE, 188, javax.swing.GroupLayout.PREFERRED_SIZE)))
                            .addGroup(jPanelOutputLayout.createSequentialGroup()
                                .addGap(21, 21, 21)
                                .addGroup(jPanelOutputLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addGroup(jPanelOutputLayout.createSequentialGroup()
                                        .addComponent(jLabelMisDat)
                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                        .addComponent(jTextMisDat, javax.swing.GroupLayout.PREFERRED_SIZE, 224, javax.swing.GroupLayout.PREFERRED_SIZE))
                                    .addGroup(jPanelOutputLayout.createSequentialGroup()
                                        .addComponent(jLabelLoc1)
                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                        .addComponent(jTextLoc, javax.swing.GroupLayout.PREFERRED_SIZE, 70, javax.swing.GroupLayout.PREFERRED_SIZE)
                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                        .addComponent(jLabelLoc2)))))))
                .addGap(0, 0, Short.MAX_VALUE))
        );

        jPanelOutputLayout.linkSize(javax.swing.SwingConstants.HORIZONTAL, new java.awt.Component[] {jTextBurr, jTextLoc});

        jPanelOutputLayout.linkSize(javax.swing.SwingConstants.HORIZONTAL, new java.awt.Component[] {jTextBurrOut, jTextFieldxCoan, jTextFieldxHet, jTextFieldxLD, jTextFieldxTemp, jTextLocOut});

        jPanelOutputLayout.setVerticalGroup(
            jPanelOutputLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanelOutputLayout.createSequentialGroup()
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addGroup(jPanelOutputLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel4)
                    .addComponent(jTextOutFolder, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jButtonOutFolder))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanelOutputLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel5)
                    .addComponent(jTextOutFile, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jCheckName))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jCheckAppend)
                .addGap(18, 18, 18)
                .addGroup(jPanelOutputLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel6)
                    .addComponent(jLabel8)
                    .addComponent(jCheckTab))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addGroup(jPanelOutputLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jCheckXtraOut)
                    .addComponent(jTextFieldxLD, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jTextXCrit, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jLabelxOut2)
                    .addComponent(jLabelxOut1)
                    .addComponent(jLabelxOut3))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanelOutputLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jTextFieldxHet, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jTextFieldxCoan, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jTextFieldxTemp, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addGroup(jPanelOutputLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jCheckBurr)
                    .addComponent(jTextBurrOut, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanelOutputLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabelBur1)
                    .addComponent(jTextBurr, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jLabelBur2)
                    .addComponent(jLabelBur3)
                    .addComponent(jTextBCrit, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addGroup(jPanelOutputLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jCheckLocOut)
                    .addComponent(jTextLocOut, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanelOutputLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jButtonParamFile)
                    .addComponent(jTextLoc, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jLabelLoc2)
                    .addComponent(jLabelLoc1))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanelOutputLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jButtonExit)
                    .addComponent(jTextMisDat, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jLabelMisDat))
                .addGap(14, 14, 14))
        );

        jPanelPcrit.setBorder(javax.swing.BorderFactory.createTitledBorder(null, "Critical Values", javax.swing.border.TitledBorder.DEFAULT_JUSTIFICATION, javax.swing.border.TitledBorder.DEFAULT_POSITION, new java.awt.Font("Times New Roman", 1, 12))); // NOI18N

        listPcrit.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                listPcritActionPerformed(evt);
            }
        });

        jTextPcrit.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyPressed(java.awt.event.KeyEvent evt) {
                jTextPcritKeyPressed(evt);
            }
            public void keyReleased(java.awt.event.KeyEvent evt) {
                jTextPcritKeyReleased(evt);
            }
        });

        jButtonAdd.setText("<<<  Add  ");
        jButtonAdd.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonAddActionPerformed(evt);
            }
        });

        jLabelP1.setText("To delete an item on the list,");

        jLabelP2.setText("highlight it, then");

        jButtonDel.setText("Delete");
        jButtonDel.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonDelActionPerformed(evt);
            }
        });

        jCheckPcrit0.setText("Also run without frequency restriction");
        jCheckPcrit0.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jCheckPcrit0ActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout jPanelPcritLayout = new javax.swing.GroupLayout(jPanelPcrit);
        jPanelPcrit.setLayout(jPanelPcritLayout);
        jPanelPcritLayout.setHorizontalGroup(
            jPanelPcritLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanelPcritLayout.createSequentialGroup()
                .addGroup(jPanelPcritLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanelPcritLayout.createSequentialGroup()
                        .addComponent(listPcrit, javax.swing.GroupLayout.PREFERRED_SIZE, 64, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(jPanelPcritLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                            .addGroup(jPanelPcritLayout.createSequentialGroup()
                                .addComponent(jTextPcrit, javax.swing.GroupLayout.PREFERRED_SIZE, 52, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(jButtonAdd, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                            .addComponent(jLabelP1)
                            .addGroup(jPanelPcritLayout.createSequentialGroup()
                                .addComponent(jLabelP2)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(jButtonDel))))
                    .addComponent(jCheckPcrit0))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
        jPanelPcritLayout.setVerticalGroup(
            jPanelPcritLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanelPcritLayout.createSequentialGroup()
                .addGroup(jPanelPcritLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)
                    .addComponent(listPcrit, javax.swing.GroupLayout.PREFERRED_SIZE, 0, Short.MAX_VALUE)
                    .addGroup(jPanelPcritLayout.createSequentialGroup()
                        .addGroup(jPanelPcritLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(jTextPcrit, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(jButtonAdd))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jLabelP1)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(jPanelPcritLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(jLabelP2)
                            .addComponent(jButtonDel))))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jCheckPcrit0, javax.swing.GroupLayout.PREFERRED_SIZE, 16, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(0, 0, Short.MAX_VALUE))
        );

        jPanelOption.setBorder(javax.swing.BorderFactory.createTitledBorder(null, "Options", javax.swing.border.TitledBorder.DEFAULT_JUSTIFICATION, javax.swing.border.TitledBorder.DEFAULT_POSITION, new java.awt.Font("Times New Roman", 1, 12))); // NOI18N

        jCheckPop.setText("Population range to run:");
        jCheckPop.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jCheckPopActionPerformed(evt);
            }
        });

        jCheckSamp.setText("Up to individual per pop:");
        jCheckSamp.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jCheckSampActionPerformed(evt);
            }
        });

        jCheckLoc.setText("Restrict Loci by");
        jCheckLoc.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jCheckLocActionPerformed(evt);
            }
        });

        buttonGroup2.add(jRadioButtonRange);
        jRadioButtonRange.setText("Ranges:");
        jRadioButtonRange.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jRadioButtonRangeActionPerformed(evt);
            }
        });

        buttonGroup2.add(jRadioButtonDel);
        jRadioButtonDel.setText("Omitting Loci:");
        jRadioButtonDel.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jRadioButtonDelActionPerformed(evt);
            }
        });

        jTextPop.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyPressed(java.awt.event.KeyEvent evt) {
                jTextPopKeyPressed(evt);
            }
            public void keyReleased(java.awt.event.KeyEvent evt) {
                jTextPopKeyReleased(evt);
            }
        });

        jTextSamp.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyPressed(java.awt.event.KeyEvent evt) {
                jTextSampKeyPressed(evt);
            }
            public void keyReleased(java.awt.event.KeyEvent evt) {
                jTextSampKeyReleased(evt);
            }
        });

        jTextRange.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyPressed(java.awt.event.KeyEvent evt) {
                jTextRangeKeyPressed(evt);
            }
            public void keyReleased(java.awt.event.KeyEvent evt) {
                jTextRangeKeyReleased(evt);
            }
        });

        jTextLocDel.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyPressed(java.awt.event.KeyEvent evt) {
                jTextLocDelKeyPressed(evt);
            }
            public void keyReleased(java.awt.event.KeyEvent evt) {
                jTextLocDelKeyReleased(evt);
            }
        });

        jCheckBoxCI.setText("No Output for Confidence Intervals");
        jCheckBoxCI.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jCheckBoxCIActionPerformed(evt);
            }
        });

        jButtonLoci.setText("?");
        jButtonLoci.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonLociActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout jPanelOptionLayout = new javax.swing.GroupLayout(jPanelOption);
        jPanelOption.setLayout(jPanelOptionLayout);
        jPanelOptionLayout.setHorizontalGroup(
            jPanelOptionLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanelOptionLayout.createSequentialGroup()
                .addGap(21, 21, 21)
                .addGroup(jPanelOptionLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addGroup(javax.swing.GroupLayout.Alignment.LEADING, jPanelOptionLayout.createSequentialGroup()
                        .addComponent(jRadioButtonDel)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jTextLocDel))
                    .addGroup(javax.swing.GroupLayout.Alignment.LEADING, jPanelOptionLayout.createSequentialGroup()
                        .addComponent(jRadioButtonRange)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jTextRange))))
            .addGroup(jPanelOptionLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jCheckBoxCI)
                .addGap(0, 0, Short.MAX_VALUE))
            .addGroup(jPanelOptionLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanelOptionLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addGroup(jPanelOptionLayout.createSequentialGroup()
                        .addComponent(jCheckSamp)
                        .addGap(18, 18, 18)
                        .addComponent(jTextSamp))
                    .addGroup(jPanelOptionLayout.createSequentialGroup()
                        .addComponent(jCheckLoc)
                        .addGap(6, 6, 6)
                        .addComponent(jButtonLoci))
                    .addGroup(jPanelOptionLayout.createSequentialGroup()
                        .addComponent(jCheckPop)
                        .addGap(7, 7, 7)
                        .addComponent(jTextPop, javax.swing.GroupLayout.PREFERRED_SIZE, 77, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addContainerGap())
        );
        jPanelOptionLayout.setVerticalGroup(
            jPanelOptionLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanelOptionLayout.createSequentialGroup()
                .addComponent(jCheckBoxCI)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanelOptionLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jCheckPop)
                    .addComponent(jTextPop, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanelOptionLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jCheckSamp)
                    .addComponent(jTextSamp, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanelOptionLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jCheckLoc)
                    .addComponent(jButtonLoci))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanelOptionLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jRadioButtonRange)
                    .addComponent(jTextRange, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanelOptionLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jRadioButtonDel)
                    .addComponent(jTextLocDel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        jButtonRun.setFont(new java.awt.Font("Tahoma", 1, 11)); // NOI18N
        jButtonRun.setText(">>>    Run Ne Estimator    >>>");
        jButtonRun.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonRunActionPerformed(evt);
            }
        });

        jMenuFile.setText("File      ");

        jMenuInput.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_I, java.awt.event.InputEvent.ALT_MASK | java.awt.event.InputEvent.CTRL_MASK));
        jMenuInput.setText("Choose Input File");
        jMenuInput.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuInputActionPerformed(evt);
            }
        });
        jMenuFile.add(jMenuInput);
        jMenuFile.add(jSeparator1);

        jMenuParam.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_P, java.awt.event.InputEvent.ALT_MASK | java.awt.event.InputEvent.CTRL_MASK));
        jMenuParam.setText("Create Parameter Files to run command line");
        jMenuParam.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuParamActionPerformed(evt);
            }
        });
        jMenuFile.add(jMenuParam);

        jMenuSave.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_S, java.awt.event.InputEvent.ALT_MASK | java.awt.event.InputEvent.CTRL_MASK));
        jMenuSave.setText("Save Settings");
        jMenuSave.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuSaveActionPerformed(evt);
            }
        });
        jMenuFile.add(jMenuSave);

        jMenuExit.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_X, java.awt.event.InputEvent.ALT_MASK | java.awt.event.InputEvent.CTRL_MASK));
        jMenuExit.setText("Exit");
        jMenuExit.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuExitActionPerformed(evt);
            }
        });
        jMenuFile.add(jMenuExit);

        jMenuBar1.add(jMenuFile);

        jMenuAction.setText("Run      ");

        jMenuRun.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_R, java.awt.event.InputEvent.ALT_MASK | java.awt.event.InputEvent.CTRL_MASK));
        jMenuRun.setText("Run Ne");
        jMenuRun.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuRunActionPerformed(evt);
            }
        });
        jMenuAction.add(jMenuRun);
        jMenuAction.add(jSeparator2);

        jMenuTerm.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_T, java.awt.event.InputEvent.ALT_MASK | java.awt.event.InputEvent.CTRL_MASK));
        jMenuTerm.setText("Open Terminal for Command");
        jMenuTerm.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuTermActionPerformed(evt);
            }
        });
        jMenuAction.add(jMenuTerm);

        jMenuBar1.add(jMenuAction);

        jMenu2.setText("Help");

        jMenuAbout.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_A, java.awt.event.InputEvent.ALT_MASK));
        jMenuAbout.setText("About ...");
        jMenuAbout.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuAboutActionPerformed(evt);
            }
        });
        jMenu2.add(jMenuAbout);
        jMenu2.add(jSeparator3);

        jMenuHelpFile.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_F1, java.awt.event.InputEvent.ALT_MASK));
        jMenuHelpFile.setText("Launch Documentation/Help File");
        jMenuHelpFile.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuHelpFileActionPerformed(evt);
            }
        });
        jMenu2.add(jMenuHelpFile);

        jMenuBar1.add(jMenu2);

        setJMenuBar(jMenuBar1);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jPanelInput, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(jPanelOutput, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jPanelOption, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(jPanelPcrit, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(jPanelMethod, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(jButtonRun, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addComponent(jPanelInput, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(jPanelMethod, javax.swing.GroupLayout.DEFAULT_SIZE, 0, Short.MAX_VALUE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jPanelPcrit, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(4, 4, 4)
                        .addComponent(jPanelOption, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(3, 3, 3)
                        .addComponent(jButtonRun, javax.swing.GroupLayout.PREFERRED_SIZE, 38, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addComponent(jPanelOutput, javax.swing.GroupLayout.DEFAULT_SIZE, 0, Short.MAX_VALUE))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void jButtonInpFolderActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonInpFolderActionPerformed
        // TODO add your handling code here:
   // if there is no change in directory, don't need to refresh comboBox
        if (!changeDirectory(jTextInpFolder)) return;
        String theDirectory = jTextInpFolder.getText();
        // if output folder never changed by the user, default to input folder:
        if (!setOutFolder) jTextOutFolder.setText(theDirectory);
        loadFilesToCombo(theDirectory, jComboBoxFile,
                endsBy, jCheckFileType.isSelected());
        // since this is a different folder, should always empty jTextShow:
        jTextShow.setText("");
    }//GEN-LAST:event_jButtonInpFolderActionPerformed

    private void jComboBoxFileActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jComboBoxFileActionPerformed
        // TODO add your handling code here:
        if (suppressed) return;
        String newFile = getFile(jComboBoxFile);
        if (newFile.equals("")) return;
        jTextBurrOut.setText(outputName(burSuf + outExt));
        jTextLocOut.setText(outputName(locSuf + outExt));
        jTextMisDat.setText(outputName(misSuf + outExt));
        String allCap = newFile.toUpperCase();
        if (allCap.endsWith(".DAT")) {
            jRadioButtonFstat.setSelected(true);
        } else if (allCap.endsWith(".GEN")) {
            jRadioButtonGen.setSelected(true);
        }
        if (!comboChanged) {
            if (!currFile.equals(newFile)) {
                jTextShow.setText("");
                jTextMisDat.setEnabled(false);
// cover the next code to ALWAYS set back to default output name when
// new input is chosen.
// The "if" condition here is that output file is NOT in append mode.
// (When in append mode, it is assumed that the user want to use the same
// output name for several different input files, so don't set to default.)
                if (!jCheckAppend.isSelected())
                    jCheckName.setSelected(true);
            }
        }
        if (jCheckName.isSelected()) {
            jTextOutFile.setText(outputName(getSuffix() + outExt));
//            xOutputName();
            xOutputNames();
        }
        currFile = getFile(jComboBoxFile);
        // show Line 1 of currFile:
        String path = jTextInpFolder.getText().trim();
        if (currPath.equals(path) && samePath) path = "";
        else path += File.separatorChar;
        // now print first line of the file to jTextShow
        String line1 = getFirstLineAtFile(path + currFile);
        jTextShow.setText("");
        if (line1.length() > 0) {
            jTextShow.setText(line1.substring(1));
        }
    }//GEN-LAST:event_jComboBoxFileActionPerformed

    private void jCheckFileTypeActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jCheckFileTypeActionPerformed
        // TODO add your handling code here:
        String theDirectory = jTextInpFolder.getText();
        comboChanged = true; // set this = true so that when loadFilesToCombo
        // is called, which activates event jComboBoxFileActionPerformed,
        // the textbox jTextShow is not emptied in that event.
        boolean fileChanged = loadFilesToCombo(theDirectory, jComboBoxFile,
                endsBy, jCheckFileType.isSelected());
//        if (fileChanged)
        if (fileChanged || (jComboBoxFile.getSelectedIndex() == -1))
            jTextShow.setText("");
        comboChanged = false;
    }//GEN-LAST:event_jCheckFileTypeActionPerformed

    private void jCheckLDActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jCheckLDActionPerformed
        // TODO add your handling code here:
        chooseMethod();
//        showLDfile();
        showxFile();
        if (jCheckName.isSelected()) {
            jTextOutFile.setText(outputName(getSuffix() + outExt));
            jTextOutFile.setEditable(false);
        }
        xOutputNames();
//        xOutputName();
        if (jCheckLD.isSelected()) {
            jRadioButtonRan.setEnabled(true);
            jRadioButtonMono.setEnabled(true);
        } else {
            jRadioButtonRan.setEnabled(false);
            jRadioButtonMono.setEnabled(false);
        }
    }//GEN-LAST:event_jCheckLDActionPerformed

    private void jCheckHetActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jCheckHetActionPerformed
        // TODO add your handling code here:
        chooseMethod();
        showxFile();
        if (jCheckName.isSelected()) {
            jTextOutFile.setText(outputName(getSuffix() + outExt));
            jTextOutFile.setEditable(false);
        }
        xOutputNames();
    }//GEN-LAST:event_jCheckHetActionPerformed

    private void jCheckTempActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jCheckTempActionPerformed
        // TODO add your handling code here:
        chooseMethod();
        showxFile();
        if (jCheckName.isSelected()) {
            jTextOutFile.setText(outputName(getSuffix() + outExt));
            jTextOutFile.setEditable(false);
        }
        if (jCheckTemp.isSelected()) {
            jTextTemp.setEnabled(true);
//            jButtonTpMethod.setEnabled(true);
            jButtonTemp.setEnabled(true);
        } else {
            jTextTemp.setEnabled(false);
//            jButtonTpMethod.setEnabled(false);
            jButtonTemp.setEnabled(false);
        }
        xOutputNames();
        setToolTipTemporal();
    }//GEN-LAST:event_jCheckTempActionPerformed

    private void jButtonAddActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonAddActionPerformed
        // TODO add your handling code here:

        int k = addToList(listPcrit, jTextPcrit.getText(), maxListSize,0, 0.5F);
        if (k == 1) {
            jTextPcrit.setText("");
            jTextPcrit.requestFocusInWindow();
        }
        if (k == 0) {
            if ((listPcrit.getItemCount() == 1) && (!crit0Checked) &&
                    (!jCheckCoan.isSelected()))
                jCheckPcrit0.setSelected(false);
        }
    }//GEN-LAST:event_jButtonAddActionPerformed

    private void jButtonDelActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonDelActionPerformed
        // TODO add your handling code here:
        int i = listPcrit.getSelectedIndex();
        if (i >= 0) listPcrit.remove(i);
        else return;
        if (!jCheckPcrit0.isSelected()) crit0Checked = false;
        if (listPcrit.getItemCount() == 0) {
            jCheckPcrit0.setSelected(true);
        }
    }//GEN-LAST:event_jButtonDelActionPerformed

    private void jButtonOutFolderActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonOutFolderActionPerformed
        // TODO add your handling code here:
        // When the user manually changes directory for outputs,
        // setOutFolder = true. This variable was set true the first time
        // that this call changeDirectory is true, and remains so after
        // subsequent calls, regardless of its return value.
        if (changeDirectory(jTextOutFolder)) setOutFolder = true;
    }//GEN-LAST:event_jButtonOutFolderActionPerformed

    private void jTextOutFileActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jTextOutFileActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_jTextOutFileActionPerformed

    private void jTextOutFileKeyPressed(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_jTextOutFileKeyPressed
        // TODO add your handling code here:
        setCaret(jTextOutFile);
    }//GEN-LAST:event_jTextOutFileKeyPressed

    private void jTextOutFileFocusLost(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_jTextOutFileFocusLost
        // TODO add your handling code here:
        // trim the text:
        jTextOutFile.setText(jTextOutFile.getText().trim());
    }//GEN-LAST:event_jTextOutFileFocusLost

    private void jCheckNameActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jCheckNameActionPerformed
        // TODO add your handling code here:
        if (jCheckName.isSelected()) {
            jTextOutFile.setText(outputName(getSuffix() + outExt));
//            xOutputName();
            xOutputNames();
            jTextOutFile.setEditable(false);
        } else {
            jTextOutFile.setEditable(true);
            jTextOutFile.requestFocusInWindow();
        }
    }//GEN-LAST:event_jCheckNameActionPerformed

    private void jButtonExitActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonExitActionPerformed
        // TODO add your handling code here:
//        if (pr != null) pr.destroy();
        saveSetup(iniFileName);
        System.exit(0);
    }//GEN-LAST:event_jButtonExitActionPerformed

    private void jCheckPopActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jCheckPopActionPerformed
        // TODO add your handling code here:
        if (jCheckPop.isSelected()) {
            jTextPop.setEnabled(true);
            jTextPop.requestFocusInWindow();
        } else {
            jTextPop.setEnabled(false);
        }
	setToolTipPop();
    }//GEN-LAST:event_jCheckPopActionPerformed

    private void jCheckSampActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jCheckSampActionPerformed
        // TODO add your handling code here:
        if (jCheckSamp.isSelected()) {
            jTextSamp.setEnabled(true);
            jTextSamp.requestFocusInWindow();
        } else {
            jTextSamp.setEnabled(false);
        }
	setToolTipSamp();
    }//GEN-LAST:event_jCheckSampActionPerformed

    private void jCheckLocActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jCheckLocActionPerformed
        // TODO add your handling code here:
        if (jCheckLoc.isSelected()) {
            jRadioButtonRange.setEnabled(true);
            jRadioButtonDel.setEnabled(true);
            jButtonLoci.setEnabled(true);
            if (jRadioButtonRange.isSelected()) {
                jTextRange.setEnabled(true);
            } else {
                jTextRange.setEnabled(false);
            }
            if (jRadioButtonDel.isSelected()) {
                jTextLocDel.setEnabled(true);
            } else {
                jTextLocDel.setEnabled(false);
            }
        } else {
            jRadioButtonRange.setEnabled(false);
            jRadioButtonDel.setEnabled(false);
            jTextRange.setEnabled(false);
            jTextLocDel.setEnabled(false);
            jButtonLoci.setEnabled(false);
        }
	setToolTipRestrictLoc();
    }//GEN-LAST:event_jCheckLocActionPerformed

    private void jRadioButtonRangeActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jRadioButtonRangeActionPerformed
        // TODO add your handling code here:
        if (jRadioButtonRange.isSelected()) {
            jTextRange.setEnabled(true);
            jTextRange.requestFocusInWindow();
            jTextLocDel.setEnabled(false);
        } else {
            jTextRange.setEnabled(false);
        }
//	setToolTipRange(jRadioButtonRange.isSelected());
        setToolTipLocText();
    }//GEN-LAST:event_jRadioButtonRangeActionPerformed

    private void jRadioButtonDelActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jRadioButtonDelActionPerformed
        // TODO add your handling code here:
        if (jRadioButtonDel.isSelected()) {
            jTextLocDel.setEnabled(true);
            jTextLocDel.requestFocusInWindow();
            jTextRange.setEnabled(false);
        } else {
            jTextLocDel.setEnabled(false);
        }
        setToolTipLocText();
//	setToolTipLocDel(jRadioButtonDel.isSelected());
    }//GEN-LAST:event_jRadioButtonDelActionPerformed

    private void jButtonRunActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonRunActionPerformed
        // TODO add your handling code here:
        exeNeRun();
    }//GEN-LAST:event_jButtonRunActionPerformed

    private void jCheckCoanActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jCheckCoanActionPerformed
        // TODO add your handling code here:
        chooseMethod();
        showxFile();
        if (jCheckName.isSelected()) {
            jTextOutFile.setText(outputName(getSuffix() + outExt));
            jTextOutFile.setEditable(false);
        }
        xOutputNames();
        // add in Oct 2013
        if (jCheckCoan.isSelected()) jCheckPcrit0.setSelected(true);
    }//GEN-LAST:event_jCheckCoanActionPerformed

    private void jComboBoxFileMouseEntered(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_jComboBoxFileMouseEntered
        // TODO add your handling code here:
    }//GEN-LAST:event_jComboBoxFileMouseEntered

    private void jComboBoxFileMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_jComboBoxFileMouseClicked
        // TODO add your handling code here:
    }//GEN-LAST:event_jComboBoxFileMouseClicked

    private void jComboBoxFileFocusGained(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_jComboBoxFileFocusGained
        // TODO add your handling code here:
        String theDirectory = jTextInpFolder.getText();
//        comboChanged = true; // set this = true so that when loadFilesToCombo
        // is called, which activates event jComboBoxFileActionPerformed,
        // the textbox jTextShow is not emptied in that event.
        boolean fileChanged = loadFilesToCombo(theDirectory, jComboBoxFile,
                endsBy, jCheckFileType.isSelected());
//        if (fileChanged) jTextShow.setText("");
        comboChanged = false;
    }//GEN-LAST:event_jComboBoxFileFocusGained

    private void jTextOutFileKeyReleased(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_jTextOutFileKeyReleased
        // TODO add your handling code here:
        // no more than maxNameSize chars for name
        acceptOnly(jTextOutFile, fileChars, maxNameSize, caretPos, origCaret);
        released = true;
        xOutputNames();
//        xOutputName();
    }//GEN-LAST:event_jTextOutFileKeyReleased

    private void jButtonInfoActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonInfoActionPerformed
        // TODO add your handling code here:
        String fileName = getFile(jComboBoxFile);
        isGoodToGo(fileName, jRadioButtonGen.isSelected(), true);
    }//GEN-LAST:event_jButtonInfoActionPerformed

    private void jCheckBurrActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jCheckBurrActionPerformed
        // TODO add your handling code here:
        if (jCheckBurr.isSelected()) {
            jTextBurr.setEnabled(true);
            jTextBCrit.setEnabled(true);
            jTextBurrOut.setEnabled(true);
            jTextBurr.requestFocusInWindow();
        } else {
            jTextBurr.setEnabled(false);
            jTextBCrit.setEnabled(false);
            jTextBurrOut.setEnabled(false);
        }
        setToolTipBurTxt();
        setToolTip(jTextBCrit, tipBCrit);
    }//GEN-LAST:event_jCheckBurrActionPerformed

    private void jCheckLocOutActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jCheckLocOutActionPerformed
        // TODO add your handling code here:
        if (jCheckLocOut.isSelected()) {
            jTextLoc.setEnabled(true);
            jTextLocOut.setEnabled(true);
            jTextLoc.requestFocusInWindow();
        } else {
            jTextLoc.setEnabled(false);
            jTextLocOut.setEnabled(false);
        }
        setToolTip(jTextLoc, tipOneRange);
    }//GEN-LAST:event_jCheckLocOutActionPerformed

    private void jTextBurrKeyReleased(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_jTextBurrKeyReleased
        // TODO add your handling code here:
//        acceptOnly(jTextBurr, digits + "-", "-", 11, caretPos, origCaret);
        acceptOnly(jTextBurr, digits + "-", "-", 1, 11, caretPos, origCaret);
        released = true;
    }//GEN-LAST:event_jTextBurrKeyReleased

    private void jTextLocKeyReleased(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_jTextLocKeyReleased
        // TODO add your handling code here:
//        acceptOnly(jTextLoc, digits + "-", "-", 11, caretPos, origCaret);
        acceptOnly(jTextLoc, digits + "-", "-", 1, 11, caretPos, origCaret);
        released = true;
    }//GEN-LAST:event_jTextLocKeyReleased

    private void jTextPopKeyReleased(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_jTextPopKeyReleased
        // TODO add your handling code here:
//        acceptOnly(jTextPop, digits + "-", "-", 11, caretPos, origCaret);
        acceptOnly(jTextPop, digits + "-", "-", 1, 11, caretPos, origCaret);
        released = true;
    }//GEN-LAST:event_jTextPopKeyReleased

    private void jTextSampKeyReleased(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_jTextSampKeyReleased
        // TODO add your handling code here:
        acceptOnly(jTextSamp, digits, 6, caretPos, origCaret);
        released = true;
    }//GEN-LAST:event_jTextSampKeyReleased

    private void jCheckXtraOutActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jCheckXtraOutActionPerformed
        // TODO add your handling code here:
        jTextFieldxLD.setEnabled(false);
        jTextFieldxHet.setEnabled(false);
        jTextFieldxCoan.setEnabled(false);
        jTextFieldxTemp.setEnabled(false);
        jTextXCrit.setEnabled(false);
        // add in July 2013 involving jCheckTab
        jCheckTab.setEnabled(false);
        if (jCheckXtraOut.isSelected()) {
            if (jCheckLD.isSelected()) jTextFieldxLD.setEnabled(true);
            if (jCheckHet.isSelected()) jTextFieldxHet.setEnabled(true);
            if (jCheckCoan.isSelected()) jTextFieldxCoan.setEnabled(true);
            if (jCheckTemp.isSelected()) jTextFieldxTemp.setEnabled(true);
            if (jLabelxOut1.isEnabled()) {
                jTextXCrit.setEnabled(true);
                jTextXCrit.requestFocusInWindow();
                jTextXCrit.setCaretPosition(0);
            }
            jCheckTab.setEnabled(true);
        }
        setToolTip(jTextXCrit, tipBCrit);   // tooltip same as in jTextBCrit
        setToolTipTab();
        xOutputNames();
    }//GEN-LAST:event_jCheckXtraOutActionPerformed

    private void jButtonParamFileActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonParamFileActionPerformed
        // TODO add your handling code here:
        makeParamFile();
    }//GEN-LAST:event_jButtonParamFileActionPerformed

    private void jCheckBoxCIActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jCheckBoxCIActionPerformed
        // TODO add your handling code here:
        if (jCheckBoxCI.isSelected()) hasCI = 0;
        else hasCI = 1;
    }//GEN-LAST:event_jCheckBoxCIActionPerformed

    private void jRadioButtonRanActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jRadioButtonRanActionPerformed
        // TODO add your handling code here:
        randLD = 0;
    }//GEN-LAST:event_jRadioButtonRanActionPerformed

    private void jRadioButtonMonoActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jRadioButtonMonoActionPerformed
        // TODO add your handling code here:
        randLD = 1;
    }//GEN-LAST:event_jRadioButtonMonoActionPerformed

    private void jButtonTempActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonTempActionPerformed
        // TODO add your handling code here:
        String generations = jTextTemp.getText().trim();
        displayGeneration(generations, tPlan, true);
    }//GEN-LAST:event_jButtonTempActionPerformed

    private void jButtonLociActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonLociActionPerformed
        // TODO add your handling code here:
        String msg = getLociInst();
        // Check Range:
        String content = jTextRange.getText().trim();
/*
        String revisedR = finalRanges(content);
        // if there is error, the string revisedR contains the word "Error"
//*
        boolean showRange = false;
        // the purpose of variable showRange is whether to insert a new line
        // before showing omitted loci. It is true when there are entries in
        // the Range textbox.
        if (revisedR.indexOf('E') != -1) {
            msg += newline + newline + "* " + revisedR;
            showRange = true;
        } else if (revisedR.length() != 0) {
            String edited = editedRange(revisedR);
            // edited contains ranges (by one dash between 2 numbers separated
            // by a comma. Now, to count the total number of loci, replace
            // commas by blanks so that we can count the total number of ranges.
            // Then for each range, which is a token, clear the dash to break
            // it into 2 tokens so that we know the number inthe range.
            String noComma = edited.replace(',', ' ');
            // the difference between noComma and revisedR is noComma still
            // carries dashes, but revisedR has no dash.
            int n = getNumTokens(noComma); // n ranges
            int k = 0;
            for (int i =0; i < n; i++) {
                String range = getFirstToken(noComma);
                range = range.replace('-', ' ');
                if (getNumTokens(range) == 1) k++;
                else {
                    String first = getFirstToken(range);
                    String second = range.substring(first.length()+1);
                    int j = getPositiveInt(second) - getPositiveInt(first) + 1;
                    k += j;
                }
                if (i < n-1) noComma = noComma.substring(range.length()+1);
            }
            msg += newline + newline + "* 'Range' box shows "
            	 		+ k + " loci.";
//            if (!revisedR.equals(content)) {
            if (edited.length() < content.length()) {
                msg += " The entries have been truncated.";
                jTextRange.setText(edited);
            }
            showRange = true;
        }

        // Check Omitted Loci:
        content = content.replace(',', ' ');
        String revised = revisedLocDel(content, false);
        if (revised.length() != 0) {
        // there are entries in textbox jTextLocDel
            msg += newline;
            if (!showRange) msg += newline;
            if (revised.indexOf('E') == -1) {
                int n = getNumTokens(revised);
                msg += "* There are " + n + " loci to be omitted.";
                if (revised.length() < content.length()) {
                    msg += " The entries have been truncated.";
                    revised = revised.replace(' ', ',');
                    jTextLocDel.setText(revised);
                }
            } else {
                msg += "* In 'Omitting Loci:' " + revised + " (Rule 1)";
            }
        }
//*/
        boolean showRange = (content.length() != 0);
        // the purpose of variable showRange is whether to insert a new line
        // before showing omitted loci. It is true when there are entries in
        // the Range textbox.
        StringBuilder display = new StringBuilder();
        int k = numInRange(content, display);
        if (k == -1) {
            msg += newline + newline + "* " + display.toString();
        } else if (k > 0) {
            msg += newline + newline + "* 'Range' box shows "
            	 		+ k + " loci.";
            if (display.toString().length() > 0) {
                msg += " The entries have been truncated.";
                jTextRange.setText(display.toString());
            }
        }
        // Check Omitted Loci:
        content = jTextLocDel.getText().trim();
        display = new StringBuilder();
        k = numLocDel(content, display);
        if (k != 0) {
            msg += newline;
            if (!showRange) msg += newline;
        }
        if (k == -1) {
            msg += "* In 'Omitting Loci:' " + display.toString() + " (Rule 1)";
        } else if (k > 0) {
            msg += "* 'Omitting Loci' box shows " + k + " loci to be omitted.";
            if (display.toString().length() > 0) {
                msg += " The entries have been truncated.";
                jTextLocDel.setText(display.toString());
            }
        }
//        JFrame frame = new JFrame();
//        JOptionPane.showMessageDialog(frame, showMe);
        JOptionPane.showMessageDialog(this, msg, "Guide for Loci Restriction",
                JOptionPane.INFORMATION_MESSAGE);
    }//GEN-LAST:event_jButtonLociActionPerformed

    private void jTextBurrActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jTextBurrActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_jTextBurrActionPerformed

    private void jTextTempKeyReleased(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_jTextTempKeyReleased
        // TODO add your handling code here:
        // accept only digits, periods, and blanks, commas, slashes:
//        acceptOnly(jTextTemp, digits + "., /", "., /", caretPos, origCaret);
    // This prevents the text from having more than one slash, period, comma
    // between 2 numbers:
//        acceptOnly(jTextTemp, digits + "., /", "., /", 0, caretPos, origCaret, ' ');
    // accept ".,: /" besides digits, but no consecutive chars in ".,:"
        acceptOnly(jTextTemp, digits + ".,: /", ".,: ", 0, caretPos, origCaret, ' ');
        released = true;
    }//GEN-LAST:event_jTextTempKeyReleased

    private void jTextPcritKeyReleased(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_jTextPcritKeyReleased
        // TODO add your handling code here:
        // accept only digits, periods:
        // this is for not accepting '.' at the beginning
//        acceptOnly(jTextPcrit, digits + ".", ".", nDecimal+3,
//                                        caretPos, origCaret);
//        acceptOnly(jTextPcrit, digits + ".", nDecimal+3, caretPos, origCaret);
    // This prevents the text from having more than one period
    // between 2 numbers (use -1 for accepting '.' at the beginning):
        acceptOnly(jTextPcrit, digits + ".", ".", -1, 10, caretPos, origCaret);
        released = true;
    }//GEN-LAST:event_jTextPcritKeyReleased

    private void jTextRangeKeyReleased(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_jTextRangeKeyReleased
        // TODO add your handling code here:
        // accept only digits, blanks, commas, dashes:
        // note: there is no blank in the last string
//        acceptOnly(jTextRange, digits + ", -", ", -", caretPos, origCaret);
    // This prevents the text from having more than one both dash, comma
    // between 2 numbers:
        acceptOnly(jTextRange, digits + ", -", ", -", 0, caretPos, origCaret, ' ');
        released = true;
    }//GEN-LAST:event_jTextRangeKeyReleased

    private void jTextLocDelKeyReleased(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_jTextLocDelKeyReleased
        // TODO add your handling code here:
        // accept only digits, blanks, commas:
//        acceptOnly(jTextLocDel, digits + ", ", ", ", caretPos, origCaret);
    // This prevents the text from having more than one comma between 2 numbers:
        acceptOnly(jTextLocDel, digits + ", ", ", ", 0, caretPos, origCaret, ' ');
        released = true;
    }//GEN-LAST:event_jTextLocDelKeyReleased

    private void jTextLocDelKeyPressed(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_jTextLocDelKeyPressed
        // TODO add your handling code here:
        setCaret(jTextLocDel);
    }//GEN-LAST:event_jTextLocDelKeyPressed

    private void jTextBurrKeyPressed(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_jTextBurrKeyPressed
        // TODO add your handling code here:
        setCaret(jTextBurr);
    }//GEN-LAST:event_jTextBurrKeyPressed

    private void jTextLocKeyPressed(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_jTextLocKeyPressed
        // TODO add your handling code here:
        setCaret(jTextLoc);
    }//GEN-LAST:event_jTextLocKeyPressed

    private void jTextTempKeyPressed(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_jTextTempKeyPressed
        // TODO add your handling code here:
        setCaret(jTextTemp);
    }//GEN-LAST:event_jTextTempKeyPressed

    private void jTextPcritKeyPressed(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_jTextPcritKeyPressed
        // TODO add your handling code here:
        setCaret(jTextPcrit);
    }//GEN-LAST:event_jTextPcritKeyPressed

    private void jTextPopKeyPressed(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_jTextPopKeyPressed
        // TODO add your handling code here:
        setCaret(jTextPop);
    }//GEN-LAST:event_jTextPopKeyPressed

    private void jTextSampKeyPressed(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_jTextSampKeyPressed
        // TODO add your handling code here:
        setCaret(jTextSamp);
    }//GEN-LAST:event_jTextSampKeyPressed

    private void jTextRangeKeyPressed(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_jTextRangeKeyPressed
        // TODO add your handling code here:
        setCaret(jTextRange);
    }//GEN-LAST:event_jTextRangeKeyPressed

    private void jMenuSaveActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuSaveActionPerformed
        // TODO add your handling code here:
        saveSetup(iniFileName);
    }//GEN-LAST:event_jMenuSaveActionPerformed

    private void jMenuExitActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuExitActionPerformed
        // TODO add your handling code here:
        System.exit(0);
    }//GEN-LAST:event_jMenuExitActionPerformed

    private void jButtonTpMethodActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonTpMethodActionPerformed
        // TODO add your handling code here:
        tpMethod = getTempMethods();
    }//GEN-LAST:event_jButtonTpMethodActionPerformed

    private void jMenuRunActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuRunActionPerformed
        // TODO add your handling code here:
        exeNeRun();
    }//GEN-LAST:event_jMenuRunActionPerformed

    private void jMenuTermActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuTermActionPerformed
        // TODO add your handling code here:
        openTerminal();
    }//GEN-LAST:event_jMenuTermActionPerformed

    private void jMenuInputActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuInputActionPerformed
        // TODO add your handling code here:
        chooseInput();
    }//GEN-LAST:event_jMenuInputActionPerformed

    private void jMenuAboutActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuAboutActionPerformed
        // TODO add your handling code here:
        launchAbout();
    }//GEN-LAST:event_jMenuAboutActionPerformed

    private void jMenuHelpFileActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuHelpFileActionPerformed
        // TODO add your handling code here:
        launchHelp();
    }//GEN-LAST:event_jMenuHelpFileActionPerformed

    private void jTextBCritKeyPressed(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_jTextBCritKeyPressed
        // TODO add your handling code here:
        setCaret(jTextBCrit);
    }//GEN-LAST:event_jTextBCritKeyPressed

    private void jTextBCritKeyReleased(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_jTextBCritKeyReleased
        // TODO add your handling code here:
        acceptOnly(jTextBCrit, digits, 1, caretPos, origCaret);
        released = true;
    }//GEN-LAST:event_jTextBCritKeyReleased

    private void jTextBCritActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jTextBCritActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_jTextBCritActionPerformed

    private void jTextXCritKeyPressed(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_jTextXCritKeyPressed
        // TODO add your handling code here:
        setCaret(jTextXCrit);
    }//GEN-LAST:event_jTextXCritKeyPressed

    private void jTextXCritKeyReleased(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_jTextXCritKeyReleased
        // TODO add your handling code here:
        acceptOnly(jTextXCrit, digits, 1, caretPos, origCaret);
        released = true;
    }//GEN-LAST:event_jTextXCritKeyReleased

    private void jCheckAppendActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jCheckAppendActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_jCheckAppendActionPerformed

    private void listPcritActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_listPcritActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_listPcritActionPerformed

    private void jCheckPcrit0ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jCheckPcrit0ActionPerformed
        // TODO add your handling code here:
        if (listPcrit.getItemCount() == 0 || jCheckCoan.isSelected()) {
            jCheckPcrit0.setSelected(true);
        } else {
            if (jCheckPcrit0.isSelected()) {
                crit0Checked = true;
            }
        }
    }//GEN-LAST:event_jCheckPcrit0ActionPerformed

    private void jMenuParamActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuParamActionPerformed
        // TODO add your handling code here:
        makeParamFile();
    }//GEN-LAST:event_jMenuParamActionPerformed

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /*
         * Set the Nimbus look and feel
         */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /*
         * If Nimbus (introduced in Java SE 6) is not available, stay with the
         * default look and feel. For details see
         * http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(NeGUI.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(NeGUI.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(NeGUI.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(NeGUI.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /*
         * Create and display the form
         */
        java.awt.EventQueue.invokeLater(new Runnable() {

            @Override
            public void run() {
                new NeGUI().setVisible(true);
                hasExe(exeName);
            }
        });
    }
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.ButtonGroup buttonGroup1;
    private javax.swing.ButtonGroup buttonGroup2;
    private javax.swing.ButtonGroup buttonGroup3;
    private javax.swing.JButton jButtonAdd;
    private javax.swing.JButton jButtonDel;
    private javax.swing.JButton jButtonExit;
    private javax.swing.JButton jButtonInfo;
    private javax.swing.JButton jButtonInpFolder;
    private javax.swing.JButton jButtonLoci;
    private javax.swing.JButton jButtonOutFolder;
    private javax.swing.JButton jButtonParamFile;
    private javax.swing.JButton jButtonRun;
    private javax.swing.JButton jButtonTemp;
    private javax.swing.JButton jButtonTpMethod;
    private javax.swing.JCheckBox jCheckAppend;
    private javax.swing.JCheckBox jCheckBoxCI;
    private javax.swing.JCheckBox jCheckBurr;
    private javax.swing.JCheckBox jCheckCoan;
    private javax.swing.JCheckBox jCheckFileType;
    private javax.swing.JCheckBox jCheckHet;
    private javax.swing.JCheckBox jCheckLD;
    private javax.swing.JCheckBox jCheckLoc;
    private javax.swing.JCheckBox jCheckLocOut;
    private javax.swing.JCheckBox jCheckName;
    private javax.swing.JCheckBox jCheckPcrit0;
    private javax.swing.JCheckBox jCheckPop;
    private javax.swing.JCheckBox jCheckSamp;
    private javax.swing.JCheckBox jCheckTab;
    private javax.swing.JCheckBox jCheckTemp;
    private javax.swing.JCheckBox jCheckXtraOut;
    private javax.swing.JComboBox jComboBoxFile;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel10;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JLabel jLabel6;
    private javax.swing.JLabel jLabel7;
    private javax.swing.JLabel jLabel8;
    private javax.swing.JLabel jLabelBur1;
    private javax.swing.JLabel jLabelBur2;
    private javax.swing.JLabel jLabelBur3;
    private javax.swing.JLabel jLabelLoc1;
    private javax.swing.JLabel jLabelLoc2;
    private javax.swing.JLabel jLabelMisDat;
    private javax.swing.JLabel jLabelP1;
    private javax.swing.JLabel jLabelP2;
    private javax.swing.JLabel jLabelPlan;
    private javax.swing.JLabel jLabelxOut1;
    private javax.swing.JLabel jLabelxOut2;
    private javax.swing.JLabel jLabelxOut3;
    private javax.swing.JMenu jMenu2;
    private javax.swing.JMenuItem jMenuAbout;
    private javax.swing.JMenu jMenuAction;
    private javax.swing.JMenuBar jMenuBar1;
    private javax.swing.JMenuItem jMenuExit;
    private javax.swing.JMenu jMenuFile;
    private javax.swing.JMenuItem jMenuHelpFile;
    private javax.swing.JMenuItem jMenuInput;
    private javax.swing.JMenuItem jMenuParam;
    private javax.swing.JMenuItem jMenuRun;
    private javax.swing.JMenuItem jMenuSave;
    private javax.swing.JMenuItem jMenuTerm;
    private javax.swing.JPanel jPanelInput;
    private javax.swing.JPanel jPanelMethod;
    private javax.swing.JPanel jPanelOption;
    private javax.swing.JPanel jPanelOutput;
    private javax.swing.JPanel jPanelPcrit;
    private javax.swing.JRadioButton jRadioButtonDel;
    private javax.swing.JRadioButton jRadioButtonFstat;
    private javax.swing.JRadioButton jRadioButtonGen;
    private javax.swing.JRadioButton jRadioButtonMono;
    private javax.swing.JRadioButton jRadioButtonRan;
    private javax.swing.JRadioButton jRadioButtonRange;
    private javax.swing.JPopupMenu.Separator jSeparator1;
    private javax.swing.JPopupMenu.Separator jSeparator2;
    private javax.swing.JPopupMenu.Separator jSeparator3;
    private javax.swing.JTextField jTextBCrit;
    private javax.swing.JTextField jTextBurr;
    private javax.swing.JTextField jTextBurrOut;
    private javax.swing.JTextField jTextFieldxCoan;
    private javax.swing.JTextField jTextFieldxHet;
    private javax.swing.JTextField jTextFieldxLD;
    private javax.swing.JTextField jTextFieldxTemp;
    private javax.swing.JTextField jTextInpFolder;
    private javax.swing.JTextField jTextLoc;
    private javax.swing.JTextField jTextLocDel;
    private javax.swing.JTextField jTextLocOut;
    private javax.swing.JTextField jTextMisDat;
    private javax.swing.JTextField jTextOutFile;
    private javax.swing.JTextField jTextOutFolder;
    private javax.swing.JTextField jTextPcrit;
    private javax.swing.JTextField jTextPop;
    private javax.swing.JTextField jTextRange;
    private javax.swing.JTextField jTextSamp;
    private javax.swing.JTextField jTextShow;
    private javax.swing.JTextField jTextTemp;
    private javax.swing.JTextField jTextXCrit;
    private java.awt.List listPcrit;
    // End of variables declaration//GEN-END:variables
// -----------------------------------------------------------------------
// Global Variables
    private final String[] endsBy = {".DAT", ".GEN", ".TXT"};
    private static final String digits = "0123456789";

    private final static int maxInt = 100000;  // max for loci
    // intended as maximum value for a generation:
//    private final float maxGen = 1.0E6F;
// for warning message if input file too big:
    private final int stdLoc = 1000;
    private final int stdSamp = 100;
    private final int stdRatio = 100;
//    private final int stdRatio = 100;
// temporary change the exe file name:
    private static String exeName = "Ne2";
    private String currFile = "";
    private static boolean comboChanged;
    private static String osName;
    private static String outExt = ".txt";
    private static String[] strCmd;
    private static int cmdMaxInd;
    private static String infoFile;
    private static String optFile;
    private static String currPath;
// this variable samePath = true when this program is in "jar" file
// and the loading of the jar file happens in the same directory as
// the jar file itself.
    private static boolean samePath = true;
//    private Process pr;
// this is for knowing if missing data file was present.
    private static long missDatTime = 0;
// outFileTime is for knowing if output file is actually opened by Ne
// It is used to inform the user if Ne is run successfully
    private static long outFileTime = 0;

    private static int hasCI = 1;
    private static int randLD = 0;
// these are names for parameter files to run command line:
    private static String infoParam = "info";
    private static String optParam = "option";
// used to know if option file is necessary:
    private static boolean hasOpt = false;
// to know if the user ever manually changes output folder:
    private static boolean setOutFolder = false;
// Name of the file to draw initial values for texts of some controls,
// also the file where current values to be written before closing the form
    private static String iniFileName = "initialValueNeGUI.txt";
    private static String iniGen = "0,1.5";
    private static String[] critVal = {"0.05", "0.02", "0.01"};
    private static int nDecimal = 3;
    private static int maxListSize = 9;
    private static int maxNameSize = 40;
// These are for handling keyPressed, KeyReleased in editable text fields:
    private static int caretPos = 0;    // caret Position before KeyRelease
    private static boolean released = true; // always true unless the key
    // is pressed, returns to true when the key is released
    private static int origCaret = 0;   // this is for caret position
    // when the key is pressed the first time. The variable caretPos
    // is changing when the key continued being hold down
    // this is for limiting characters that can be used in a file name:
    public static String fileChars = getFileChars();
    // this is for what temporal methods to run:
    private static int tpMethod = 0;
   // this is for suppressing event ActionPerformed at jComboBoxFile:
    private static boolean suppressed = true;
    // this is for informing that a check on current input file is performed:
    private static int numLoci = 0;
    private static int numPop = 0;
    private static int locToRun = 0;
    private static int popToRun = 0;
    private static String tipOneRange =
            "Range: 2 ascending numbers connected by a dash, " +
            "one single number for 1-element range. Empty = up to max";
//            "A single number for one population, 2"
//            + " ascending numbers connected by a dash for a range";
    private static String tipBCrit =
            "Enter 0 for Pcrit=0, leave empty: no restriction";
// the two maximum populations for Burrow and Freq outputs are set according
// to the code in the Ne program (these will reflect at the labels jLabelBur2,
// jLabelLoc2 on the form whose texts are reset by method initialize):
    private static int maxPopBur = 50;
    private static int maxPopLoc = 50;
    private static float maxRatio = 0.75F;  // ratio limit for Burrow output
    // file size as opposed to available space in disk.
    private static float sizeLim = 0.25F;   // warning ratio limit for Burrow
    private static float burrWarn = 0.5F;   // Burrow size for warning message
    private static int tPlan = 1;   // (tPlan+1) = Plan for temporal methods
    private final String[] tempMethod = {"All three methods", "Pollak",
                        "Nei/Tajima", "Pollack & Nei/Tajima", "Jorde/Ryman",
                        "Jorde/Ryman & Pollak", "Nei/Tajima & Jorde/Ryman"};

// Location (relative to current directory) of Image file for "About" menu:
    public static String aboutLoc = "Help" + File.separator + "About.png";
    public static String helpLoc = "Help" + File.separator + "help.htm";
    private String version = "NeEstimator version 2.0, Released February 2013:";
    public static ImageIcon iconAbout;
    private boolean hasImage = false;
    private String burSuf = "Bur";
    private String locSuf = "Loc";
    private String misSuf = "NoDat";
    private boolean crit0Checked = false;   
    // Except at initialize, this crit0Checked becomes true only when
    // jCheckPcrit0 was selected while the list is not empty and Coancestry
    // method is NOT selected, that is, the checkbox jCheckPcrit0 changes
    // from being NOT selected to being selected.
    // Note that this checkbox is set to be selected by code when the list
    // is empty (by "Delete" button) or Coancestry method is selected.
    // The setting by code does NOT set crit0Checked = true.
    
// -----------------------------------------------------------------------
// get the character (system dependent) for a new-line character
    public static String newline = System.getProperty("line.separator");

// =========================================================================
// currently not used (try to set maximum allowable width for the form
    private double maxWidth = java.awt.GraphicsEnvironment
                .getLocalGraphicsEnvironment().getMaximumWindowBounds().width;

// =========================================================================
    public static String getFile(javax.swing.JComboBox jComboBox1) {
//*
        if (jComboBox1.getSelectedItem() != null) return
                jComboBox1.getSelectedItem().toString();
        else return "";
//*/
/*
        int i = jComboBox1.getSelectedIndex();
        if (i == -1) return "";
        else {
            String fileName = jComboBox1.getItemAt(i).toString();
            return fileName;
        }
//*/
    }

// =========================================================================

    public String currDirectory () {
        File directory = new File (".");
        String path = "";
        try {
            path = directory.getCanonicalPath();
        } catch(Exception e) {
//            JFrame frame = new JFrame();
//            JOptionPane.showMessageDialog(frame, "Cannot locate path."
            JOptionPane.showMessageDialog(this, "Cannot locate path."
                    + newline + "Exception = " + e.getMessage());
        }
        return path;
    }
// =========================================================================

    public static boolean loadFilesToCombo (String path,
            javax.swing.JComboBox jComboBox1, String endsBy[], boolean use) {
// Load files to comboBox, return true if this comboBox is refreshed
// and the selected item is still in the new list, false otherwise.
        int i;
        String currName = "";
        if ((i = jComboBox1.getSelectedIndex()) >= 0)
            currName = jComboBox1.getItemAt(i).toString();
        String fileName;
        // this removeAllItems activates jComboBox1ActionPerformed:
        suppressed = true;  // set this so jComboBox1ActionPerformed will skip
        jComboBox1.removeAllItems();
        if ((path == null) || (path.isEmpty()) ||
                (path.trim().isEmpty()) || (!isDirectory(path))) return false;
        File folder = new File(path);
        File[] listOfFiles = folder.listFiles();
        // At the start of adding, jComboBox1ActionPerformed is activated.
        // jComboBox1ActionPerformed is activated when it is added from
        // being empty. When the box already contains some, adding another
        // item does not activate the event.
        int size = endsBy.length;
        if (!use) size = 0; // if no use of the string endsBy
        int nFiles = 0; // count files only
        for (i = 0; i < listOfFiles.length; i++)
        {
            if (listOfFiles[i].isFile()) {
                fileName = listOfFiles[i].getName();
                String filesU = fileName.toUpperCase();
                int k = 0;
                // if no use of string endsBy, size = 0: next loop is skipped
                for (; k < size; k++) {
                    if (endsBy[k].length() == 0) continue;
                    if (filesU.endsWith(endsBy[k])) break;
                }
                if (k < size || size == 0) {
                    jComboBox1.addItem(fileName);
                    nFiles++;
                }
            }
        }
        // the rest for showing back previous file name if still in the list
        for (i = 0; i < jComboBox1.getItemCount(); i++) {
            if (currName.equals(jComboBox1.getItemAt(i).toString()))
                break;
        }
        // setSelectedIndex triggers event jComboBox1ActionPerformed,
        // and we want that event runs the course, so set suppressed = false
        suppressed = false;
        if (i >= 0 && i < jComboBox1.getItemCount()) {
            jComboBox1.setSelectedIndex(i);
            return false;
        } else {
            jComboBox1.setSelectedIndex(-1);
            if (currName.length() > 0) return true;
            else return false;
        }
    }
// =========================================================================
    public static boolean setNoEditText(Container c) {
// set the first textfield in the container c to be non-editable,
        Component[] cmps = c.getComponents();
        for (Component cmp : cmps) {
            if (cmp instanceof JTextField ) {
//                ((JTextField)cmp).setEnabled(false);
                ((JTextField)cmp).setEditable(false);
                return true;
            }
            if (cmp instanceof Container) {
               if (setNoEditText((Container) cmp)) return true;
            }
        }
        return false;
    }
// =========================================================================

    public static boolean changeDirectory (javax.swing.JTextField jTextFolder) {
// assuming the text in jTextFolder contains the name of
// a directory, pop up a dialog box to choose a directory to
// put in jTextFolder. Return true if the current text is
// a directory is changed.

// This will make when a file chooser is popped up, the title for
// file name "File Name" will be "Directory Name:" instead.
        UIManager.put ("FileChooser.fileNameLabelText", "Directory Name:");
        String theDirectory = jTextFolder.getText().trim();
        String oldDirectory = theDirectory;
        if (!isDirectory(theDirectory)) return false;
        // overwrite method approveSelection to prevent
        // the choice of file: without this, clicking the
        // approve button will close the file chooser
        final JFileChooser fileChooser = new JFileChooser(theDirectory) {
            public void approveSelection() {
                if (getSelectedFile().isFile()) {
//                    return;
                } else super.approveSelection();
            }
        };
        setNoEditText(fileChooser);
        fileChooser.setDialogTitle("Choose Directory");
        fileChooser.setApproveButtonText("Choose directory");
        // use FILES_AND_DIRECTORIES because we also want to see the names of
        // files in the directories.
        // If use DIRECTORIES_ONLY, only directories are shown
        fileChooser.setFileSelectionMode(JFileChooser.FILES_AND_DIRECTORIES);
//        JFrame frame = new JFrame();
//        int result = fileChooser.showOpenDialog(frame);
        int result = fileChooser.showOpenDialog(jTextFolder.getParent().getParent());

        switch (result) {
            case JFileChooser.APPROVE_OPTION:
                File dir = fileChooser.getSelectedFile();
                boolean isDirectory = dir.isDirectory();
// Because of "final" above, the next line is unnecessary
//                if (!isDirectory) break;
                try {
                    theDirectory = dir.getAbsolutePath();
                    jTextFolder.setText(theDirectory);
                } catch(Exception e) {
//                    System.out.println("Exception =" + e.getMessage());
                    return false;
                }
                break;
            case JFileChooser.CANCEL_OPTION:
                return false;
            case JFileChooser.ERROR_OPTION:
                return false;
        }
        if (oldDirectory.trim().equals(theDirectory)) return false;
        else return true;
    }
// =========================================================================
    public static String getPrefix (String fileName, int maxlen) {
// Get prefix of fileName, which starts from the character after the last
// File Separator to right before the last dot. Take up to maxlen char
// if maxlen > 0; else unlimited (bounded by the length of fileName)
// (This code is a reflection of the code wriiten in C.)
        char c;
        char pathChar = java.io.File.separatorChar;
        int j, n, stop;
        int dot = 0;
        if (fileName == null) return "";
        String backward = "";
        fileName = fileName.trim();
        int lenPre = fileName.length();
        if (lenPre == 0) return "";
        if (maxlen <= 0) maxlen = lenPre;
    // prefix ends at the last dot '.'. Note that there may be several dots
    // in the file name, prefix ends at the last dot.
        stop = lenPre - 1;  // the index of the last visible character in the file name.
    // count number of dots
        for (n=0, j=0; j<=stop; j++) {
            if (fileName.charAt(j) == '.') n++;
        }
    // so n is at least 1 if there is a dot in the name
        if (n == 0) dot = 1;
        for (n=stop, j=0; n>=0; n--) {
            c = fileName.charAt(n);
        // no path name should be included in prefix
            if (c == pathChar) break;
            if (dot > 0 && j<maxlen) {
                backward = backward + c;
                j++;
            }
            if (c == '.') dot++;
        }
        String prefix = "";
        n = backward.length();
        for (j=n-1; j>=0; j--) {
            prefix = prefix + backward.charAt(j);
        }
        return prefix;
    }

// =========================================================================
    public static boolean fileExisted (String fileName) {
        File f = new File (fileName);
        if (f.exists()) {
            return true;
        } else return false;
    }

// =========================================================================
    public static boolean fileExisted (String path, String fileName) {
        char c = File.separatorChar;
        int n = path.length();
        if (path.charAt(n-1) == c) path = path.substring(0,n-1);
        String fullName = path + File.separatorChar + fileName;
        File f = new File (fullName);
        if (f.exists()) {
            return true;
        } else return false;
    }

// =========================================================================
    public static boolean isDirectory (String fileName) {
        File dir = new File(fileName);
        boolean isOK = false;
        if (dir.exists() && (dir.isDirectory())) isOK = true;
        return isOK;
    }

// =========================================================================

    public static String getFileChars() {
        String accept = "`~!@#$%^&()_-+={[}];',. ";
        // the above are non-alphabet, nondigit chars accepted in file name
        // (the last one is a blank, no tab).
        accept += "abcdefghijklmnopqrstuvwxyz" +
                "ABCDEFGHIJKLMNOPQRSTUVWXYZ" + digits;
        return accept;
    }

// =========================================================================
// This is written in recursive, which could cause a Stack Overflow when
// the parameter string "value" is large, so it will be replaced by the
// next one, written using loops. Comment this out as reference.
/*

    public static String acceptOnly(String value, String accept,
            String lessOf, int limit) {
    // look thru string value, eliminate any character that is not in accept
    // and return the value shrunk to size 'limit' if limit > 0.
    // The string lessOf is assumed to be a substring of accept.
    //
        char c;
        int i, k;
        int n = value.length();
    // get rid off all leading characters preceding a char in accept but not
    // in lessOf:
        for (i = 0; i < n; i++) {
            c = value.charAt(i);
            if (lessOf.indexOf(c) == -1) break;
        }
        value = value.substring(i);
        n -= i;
        if (n == 0) return value;
        //
        for (i = 0; i < n; i++) {
            c = value.charAt(i);
            if (accept.indexOf(c) == -1) break;
        }
        String reduced = value.substring(0, i);
        if (i < n) {    // a forbidden char is in the string
            String tail = value.substring(i+1, n);  // string after that char
            // the call to tail also eliminate leading "lessOf" chars in tail.
            reduced += acceptOnly(tail, accept, lessOf, 0);
        }
        n = reduced.length();
        if (limit > 0 && n > limit) reduced = reduced.substring(0, limit);
        return reduced;
    }
//*/
// =========================================================================
// The next 7 methods for accepting only characters given in string accept.
// Will be used in event KeyReleased for textboxes with appropriate 'accept'.
    public static String acceptOnly(String value, String accept,
                                    String lessOf, int limit) {
    // look thru string value, eliminate any character that is not in accept
    // and return the value shrunk to size 'limit' if limit > 0.
    // The string lessOf is assumed to be a substring of accept.
    // Characters in lessOf will be cleared if they are in front.
        char c;
        int i, k;
        String reduced = "";
        String replace = value;
        int n = replace.length();
        while (n > 0) {
            c = replace.charAt(0);
            i = 0;
            // move index i until a char not in lessOf:
            // (In effect, clear leading lessOf. If c is not in lessOf,
            // this while loop is skipped.)
            while (i < n && lessOf.indexOf(c) != -1) {
                i++;
                if (i < n) c = replace.charAt(i);
            }
            int j = i;
            if (accept.indexOf(c) != -1) {// c is in accept but not in lessOf
                // collect consecutive chars in accept (may also in lessOf):
                while (j < n && accept.indexOf(c) != -1) {
                    j++;
                    if (j < n) c = replace.charAt(j);
                }   // out of the loop, c is a forbidden char
                reduced += replace.substring(i, j);
            } else {    // c is forbidden, move j pass all forbidden chars
                while (j < n && accept.indexOf(c) == -1) {
                    j++;
                    if (j < n) c = replace.charAt(j);
                }   // out of the loop, c is in accept, could be in lessOf
            }   // then start another cycle with the next string
            replace = replace.substring(j);
            n = replace.length();
        }
        n = reduced.length();
        if (limit > 0 && n > limit) reduced = reduced.substring(0, limit);
        return reduced;
    }


// =========================================================================

    public static String acceptOnly(String value, String accept, int limit) {
        return acceptOnly(value, accept, "", limit);
    }

/*
// =========================================================================
    public static String acceptOnly(String value, String accept,
                                    String lessOf, int bound, int limit) {
    // same as the above, but the returning string should contain only
    // a maximum of "bound" characters in lessOf.
    // If bound <= 0; no restriction
        String reduced = acceptOnly(value, accept, limit);
        if (lessOf.length() == 0 || bound <= 0) return reduced;
        int len0 = reduced.length();
        String extent = acceptOnly(value, accept, lessOf, 0);
        int len = extent.length();
        // if limit > 0, the length of reduced, len0, is at most = limit,
        // while len could be bigger. If limit = 0 (i.e. no limit), then
        // len = len0.
        int i;
        int iStop = 0;
        for (i = 0; i < len; i++) {
            if (lessOf.indexOf(extent.charAt(i)) >= 0) iStop++;
            if (iStop > bound) break;
        }
        // if i < len, i is the index that string "extent" has a character
        // in lessOf, and there are "bound" characters in lessOf that
        // precede this in the string.
        // If i >= len0, the string reduced has amost "bound" characters
        // in lessOf. This condition obviously holds true if i >= len.
        if (i >= len0) return reduced;
        // now i < len0, the string reduced has more than "bound" characters
        // in lessOf. The extra ones start from index i. The substring of
        // reduced up to index (i-1) has exactly "bound" characters in lessOf.
        // We need to patch to that substring the part of "extent" consisting
        // no characters in lessOf.
        String first = reduced.substring(0, i);
        String accept0 = "";    // for characters in accept but not in lessOf
        for (int j = 0; j < accept.length(); j++) {
            char c = accept.charAt(j);
            if (lessOf.indexOf(c) >= 0) continue;
            accept0 += c;
        }
        // string "next" is substring of "extent" taken from index i,
        // erasing all characters that are in lessOf.
        String next = acceptOnly(extent.substring(i), accept0, "", 0);
        String revised = first + next;
        if (limit > 0) reduced = revised.substring(0, limit);
        else reduced = revised;
        return reduced;
    }
//*/
// =========================================================================
    public static void acceptOnly(javax.swing.JTextField jTextField1,
                            String accept, String lessOf, int limit,
                            int caretPos, int origCaret)
    // This method should be called at event KeyReleased for jTextField1.
    // This method is to clean out unwanted keys typed into jTextField1
    // when the key is released. (Referred by others as the main method.)
    // This could be:
    // 1. The user holds down a key, so a lot of characters are entered.
    // 2. The user uses Ctr-v to paste a text into a field, event KeyReleased
    //    takes effect.
    // 3. Using the mouse, the user highlights a part of the text in the field,
    //    then either types to replaces the hightlighted text or uses Ctr-v.
    // Note that in both 2 and 3, the user can also hold down Ctr-v,
    // then the text field will be pasted continuously!

    // "lessOf" should be a substring of accept. Characters in lessOf,
    // if they are in front of the text field, they will be erased.
    // Also, if they immediately followed a forbidden character
    // (i.e., char not in accept) will mostly be erased.

    // In the parameter list, caretPos is the position of the cursor (caret)
    // in the field at the time the key is pressed (before the text includes
    // the key). The parameter origCaret is the position of the cursor when
    // the key was just pressed; it is the first value of the caretPos when
    // the key is held down (the caretPos is changing during the time the key
    // is held down, its final value is right before the key is released).
    // Thus, when calling this method from event KeyReleased, the two
    // parameters origCaret and caretPos should be evaluated correctly
    // at event KeyPressed.

    // To store the value of origCaret, in the event KeyPressed, use a
    // form-level variable "released" of boolean type (= true as default),
    // as condition to assign origCaret by the caretPosition method,
    // then set "released = false" at the end of KeyPressed so that origCaret
    // won't be assigned again in case the key is held down.
    // At event KeyReleased, reset "released = true".

    // Let cr (as defined in this method) be the caret position after
    // the text is effected by the key. For example, if the cursor
    // is at position 3, and letter 'a' is typed, then caretPos = 3, cr = 4.
    // Note that cr could be < caretPos (if the key is backspace, delete, or
    // if a text is highlighted from left to right, the pased text is smaller.

    // We want to clear the text of jTextField1 of unwanted chars using
    // method acceptOnly, which as first act, clear the forbidden chars
    // (chars outside accept), and as second act, clear any string of chars
    // in lessOf if they immediately follow the forbidden one.
    // In the code, we divide in two cases:
    //      A. If cr <= caretPos + 1, apply acceptOnly to the whole newly
    //         created string, without the second act.
    //      B. Otherwise, divide the newly created string into 3 parts: head,
    //         middle, and tail. The head is substring from index 0 to
    //         (origCaret-1), the middle is substring from index origCaret to
    //         (cr-1), and the tail is substring from index cr. The tail is
    //         also the tail of the old text (i.e. before KeyPressed) and will
    //         be left alone. The head should contain the head of the old text
    //         (the old text is assumed to be the sum of its head and tail),
    //         and possibly some of the pasted text. (Details later.)
    //         Because the head may contain some pasted text, and contains the
    //         head of the old text, we still need to apply acceptOnly, but
    //         without the second act, to avoid disturbing the old text.
    //         The middle is totally inside the pasted text, so we apply
    //         acceptOnly in whole.

    // In case 1, caretPos and cr are continuously incremented by 1,
    // (except if the key is "Backspace" or "delete" then decremented by 1)
    // and cr = caretPos + 1 (if the key is "Backspace then cr = caretPos - 1).
    // In this case, always cr <= caretPos + 1. The intended text to be added
    // is a string of the same character. Assuming that key is not a delete
    // or backspace, then we either erase them all or keeping them all.
    // Note that we should not erase if the key happens to be in lessOf,
    // since we want to be able to type a lessOf char in the text field;
    // so the second act of acceptOnly should not occur. Therefore, applying
    // acceptOnly, without second act, to the whole string is appropriate.

    // We now use the term "pasted" text as the text that is to be inserted
    // into the text field. It could be a character by typing a key into
    // the field, or it could the text copied by using the mouse or Ctr-c
    // at a highlighted text elsewhere. (The "pasted" text can have negative
    // length (= -1) if it is from using delete or backspace.)

    // In case 2, if L is the length of the text to be pasted, then
    // cr = caretPos + L. If L <= 1, it is the same as typing one key, so the
    // action is just like in case 1. If L > 1, the pasted text is more than
    // one char, we wish only to work on the pasted text to clear unwanted
    // chars. At the first KeyPressed, the old (current) text is divided
    // into two parts by the origCaret position: "head"  is the part before,
    // and "tail" is the part after origCaret position.
    // We don't want accepOnly to apply second act on these two parts.
    // (Note that head is empty if the cursor is at the beginning of the text,
    // i.e., origCaret = 0, and the tail is empty if the cursor is at the
    // end of the old text at KeyPressed.)
    // Since the pasted text is inserted after the caretPos, the "head" part
    // is undisturbed by the pasting process. The "tail" part will be pushed
    // to the rear after the pasted text, and in the newly created string,
    // that part is the substring indexed from cr of the newly created string.
    // Therefore, in this newly created string, the pasted text is a substring
    // indexed from origCaret to (cr-1). we apply acceptOnly to clear this
    // substring and leave the others alone. Therefore, case B is perfect here.

    // In case 3, let L be the length of the highlighted text, and the length
    // of the pasted text at each key pressed is P (key may be Ctr-v).
    // (Unless the key is a delete or backspace, P > 0.)
    // Note that if the key is held down, the highlighted text is replaced
    // by the pasted text the first time, then the situation is back to
    // case 1 or 2, since there is no longer highlighted text to replace!
    //  (i) Suppose the text was highlighted from left to right.
    //      Then origCaret is on the right of the highlighted text.
    //      If the key pressed then released immediately, then
    //      cr = caretPos + (P - L), and caretPos = origCaret.
    //      It may be possible that cr <= caretPos + 1, and case A applies
    //      if the key is released immediately
    //      If the key is held down, then at subsequent actions of the key:
    //      caretPos = cr, cr = caretPos + P.
    //      Thus, unless P = 1 (then it is just like in case 1), case B will
    //      apply if the key is held down. In this case, a portion of the
    //      pasted text is in the "head" part as described in case B, which
    //      is no bigger than the size L of the  highlighted text.
    //      (If it is <= L, the middle is empty, also cr <= origCaret.
    //      In such case, apply acceptOnly, without second act, to the whole.)
    // (ii) Suppose the text was highlighted from right to left.
    //      Then origCaret is on the left of the highlighted text.
    //      Unbless P = 1,  we always in case B, and the whole pasted text
    //      is applied by acceptOnly with second act.

    {
        String value = jTextField1.getText();
        int n = value.length();
        if (n == 0) return;

        // Do not allow lessOf chars in front of the text field: ------------
        int i;
        for (i = 0; i < n; i++) {
            if (lessOf.indexOf(value.charAt(i)) == -1) break;
        }
        value = value.substring(i);
        n -= i;
        if (n == 0) {
            jTextField1.setText(value);
            return;
        }
        // ------------------------------------------------------------------
        // if a key is just typed into the text field, cr is the cursor
        // position after that key. However, since we will delete the first i
        // chars by previous block, should adjust accordingly.
        // (n is the "new" length):
        int cr = jTextField1.getCaretPosition() - i;
        // when using backspace, cr = caretPos-1; so if caretPos is at the
        // end of the field, and backspace is hit, caretPos > cr,
        // value cannot have index at caretPos-1, so should get out;
        // this case is handled in the next "if".
        int rightCr = n - cr;   // number of chars after caret position

        if (cr <= caretPos+1) {
        // All normal key types are in this case, some Ctr-v to paste text
        // can also be in this case if the length of the pasted text <= the
        // length of the highlighted text + 1
            value = acceptOnly(value, accept, limit);
            jTextField1.setText(value);
            // when setText, caret position is automatically at the end,
            // so need to set where it should be, otherwise, the key arrows
            // won't work. However, when the key is held down, cr could be
            // larger than the text set (a lot of forbidden chars inserted,
            // then deleted), so cannot set caret position back to cr.
            // We try to set it the same position relative to the new text:
            // (if limit>0, cr <= limit, which is the maximum length allowed)
            jTextField1.setCaretPosition(value.length() - rightCr);
            return;
        }
        // The following "head" string is supposed to be left alone.
        // However, it will contain part of the pasted text if the text
        // to be pasted was highlighted from left to right.
        // Therefore, we should also apply acceptOnly to clear unwanted
        // characters, the adjustment should not include lessOf, to preserve
        // the previous text, so some lessOf chars in the part of pasted text
        // will not be eliminated (but that part is small)
        if (cr > origCaret) {
            String head = acceptOnly(value.substring(0, origCaret),
                            accept, limit);
        // String middle is the one in the pasted text will be filtered
        // with lessOf in place:
        // the final string value should have max length = limit (if limit > 0),
        // so it's the same whether we include limit in the call of acceptOnly
            String middle = acceptOnly(value.substring(origCaret, cr),
                            accept, lessOf, limit);
            String tail = value.substring(cr);  // its length = n-cr = rightCr
            value = head + middle + tail;
        } else value = acceptOnly(value, accept, limit);
        n = value.length(); // value could come from the "if", so n may > limit
        if (limit > 0 && limit < n) {
            value = value.substring(0, limit);
            n = limit;
        }
        cr = n - rightCr;   // to be the caret position when the field is reset
        jTextField1.setText(value);
        jTextField1.setCaretPosition(cr);
    }

// =========================================================================
    public static void acceptOnly(javax.swing.JTextField jTextField1,
                    String accept, String lessOf, int bound, int limit,
                    int caretPos, int origCaret)
    // to extend the main method, put a limit number of chars in lessOf.
    // The limit is "bound." If it is 0, no restriction.
    {
        if (bound == 0) {
            acceptOnly(jTextField1, accept, lessOf, limit, caretPos, origCaret);
            return;
        }
//        acceptOnly(jTextField1, accept, lessOf, 0, caretPos, origCaret);
        // the next call does not erase lessOf chars in front:
        // (Use this and erase "lessOf" characters later so that lessOf
        // chars in between won't be erased any at all. Method acceptOnly
        // with "lessOf" in place will erase "lessOf" characters in between
        // if they immediately followed a forbidden char.)
        acceptOnly(jTextField1, accept, "", 0, caretPos, origCaret);
        int cr = jTextField1.getCaretPosition();
        String revised = jTextField1.getText();
        int n = revised.length();  //
        // clear "lessOf" characters in front when bound > 0:
        if (bound > 0)
            revised = acceptOnly(revised, accept, lessOf, 0);
        else bound = -bound;
        // if there is any deletion from the above, move caret position
        int i;
        for (i = revised.length(); i < n; i++) cr--;
        if (cr < 0) cr = 0;
        // revised contains "accept" chars only
        n = 0;  // count the number of chars in lessOf
        for (i = 0; i < revised.length(); i++) {
            char c = revised.charAt(i);
            if (lessOf.indexOf(c) == -1) continue;
            else n++;
            if (n == bound) break;
        }
        // either i = revised.length(), or at index i, character of revised
        // is the (bound+1)th character of lessOf.
        if (i < revised.length()) {
            String first = revised.substring(0, i+1);
            String second = revised.substring(i+1);
            int m = 0;  // m = number of chars in lessOf before position cr
            for (int j=i+1; j < cr; j++) {
                if (lessOf.indexOf(revised.charAt(j)) >= 0) m++;
            }
            cr -= m;    // to be caret position
            String restrict = "";   // for chars in accept but not in lessOf
            for (int j = 0; j < accept.length(); j++) {
                char c = accept.charAt(j);
                if (lessOf.indexOf(c) == -1) restrict += c;
            }
            // delete all chars of lessOf in string second.
            second = acceptOnly(second, restrict, 0);
            revised = first + second;
        }
        n = revised.length();
        if (limit > 0 && n > limit) {
            revised = revised.substring(0, limit);
            n = limit;
        }
        jTextField1.setText(revised);
        if (cr < n) jTextField1.setCaretPosition(cr);
    }

// =========================================================================
    public static void acceptOnly(javax.swing.JTextField jTextField1,
                    String accept, String lessOf, int limit,
                    int caretPos, int origCaret, char skip)
    // extend main method acceptOnly by adding a character 'skip'
    // to allowing only one character of lessOf between two characters
    // that belong to accept but not lessOf. Character skip, at input,
    // will be one in lessOf, but will not be counted for this limitation.
    {
        acceptOnly(jTextField1, accept, lessOf, 0, caretPos, origCaret);
        int cr = jTextField1.getCaretPosition();
        String start = jTextField1.getText();
        int n = start.length();
        int j = 0;
        int i;
        String revised = "";
        int m = 0;  // count the number of places that caret position cr
        // should be moved leftward when chars in lessOf are deleted
        while (n > 0) {
            for (i = 0; i < n; i++) {
                char c = start.charAt(i);
                // stop at index i if character there is in lessOf and not skip
                if (c != skip && lessOf.indexOf(c) != -1) break;
                j++;    // j is to hold index of the character as if the
                        // string start is never reassigned. It is used to
                        // reassign cr.
            }
            if (i == n) i -= 1;
            // the first character in start that is in "lessOf" but not 'skip',
            // is at index i. Take part of string "start", up to that character
            revised += start.substring(0, i+1);
            start = start.substring(i+1);
            n -= (i+1); // n now is the length of start
            if (n == 0) break;
            // now erase all chars of lessOf if they are in front of start,
            // except character skip:
            String s = "";  // to hold char skip
            for (i = 0; i < n; i++) {
                char c = start.charAt(i);
                // stop at index i if character there does not belong to lessOf
                // and not char skip (in the next if, the condition c != skip
                // is superfluous if skip is in lessOf as we actually assume)
                if (c != skip && lessOf.indexOf(c) == -1) break;
                else {
                    j++;
                    if (c == skip) s += c;
                    else if (cr > j) m++;  // this c is to be deleted,
                    // so increase m, the displacement for caret position cr.
                }
            }
            revised += s;
            start = start.substring(i);
            n -= i;
        }
        cr -= m;
        n = revised.length();
        if (limit > 0 && n > limit) {
            revised = revised.substring(0, limit);
            n = limit;
        }
        jTextField1.setText(revised);
        if (cr < n) jTextField1.setCaretPosition(cr);
    }

// =========================================================================

// absent of the 4th parameter of the main method, same as when the 4th is 0.
    public static void acceptOnly(javax.swing.JTextField jTextField1,
                String accept, String lessOf, int caretPos, int origCaret)
    {
        acceptOnly(jTextField1, accept, lessOf, 0, caretPos, origCaret);
    }


// =========================================================================
// This is the main method where the 3rd parameter is empty string.
    public static void acceptOnly(javax.swing.JTextField jTextField1,
                    String accept, int limit, int caretPos, int origCaret)
    {
        acceptOnly(jTextField1, accept, "", limit, caretPos, origCaret);
    }

// =========================================================================
// absent of the 3rd, 4th parameter, this is the main method
// where the 3rd is empty, the 4th is 0.
    public static void acceptOnly(javax.swing.JTextField jTextField1,
                            String accept, int caretPos, int origCaret)
    {
        acceptOnly(jTextField1, accept, "", 0, caretPos, origCaret);
    }
// =========================================================================
    private static void setCaret(javax.swing.JTextField jTextField1) {
    // to be called in KeyPressed event
        caretPos = jTextField1.getCaretPosition();
        if (released) origCaret = caretPos;
        // set released = false so that origCaret won't change if the key
        // is held down, it will be reset to true at event KeyReleased
        released = false;
    }
// =========================================================================

    public static int getPositiveInt(int maxAllowed, String token) {
    // get the value of the token.
    // (a token is a string of character containing no white space)
    // return -1 if the number is invalid or 0 if exceeds maxAllowed
        int k, n;
        token = token.trim();
        if ((n=token.length()) == 0) return 0;
        try {
            int num = Integer.parseInt(token);
            if (maxAllowed > 0 && num > maxAllowed) return 0;
            else return num;
        } catch (NumberFormatException e) {
            return -1;
        }
    }
// =========================================================================

    public static int getPositiveInt(String token) {
        return getPositiveInt(0, token);

    }

// =========================================================================

    public static int getPositiveInt(String line, int ind) {
    // get the value of the token at position ind as an integer,
    // (position 0 is the first)
    // (a token is a string of character containing no white space)
    // return 0 if the number is invalid (format error)
        if (ind < 0) return 0;
        line = line.trim();
        if (line.length() == 0) return 0;
        String token = getFirstToken(line);
        if (ind == 0) return getPositiveInt(token);
        String remain = line.substring(token.length());
        return getPositiveInt(remain, ind-1);
    }
// =========================================================================

    public static int[] getSequence(String line) {
    // return array of integers for numbers on the line.
    // the first element of the array is the total count.
    // Thus, the returning array always has size at least 1.
        int n = getNumTokens(line);
        int data[] = new int[n+1];
        data[0] = n;
        for (int ind = 1; ind <= n; ind++) {
            data[ind] = getPositiveInt(line, ind - 1);
        }
        return data;
    }
// =========================================================================
    public static int[] getExtremum(int data[]) {
        int value[] = new int[2];
        int minValue = data[0];
        int maxValue = data[0];
        int size = data.length;
        for (int i = 1; i < size; i++) {
            if (minValue > data[i]) minValue = data[i];
            if (maxValue < data[i]) maxValue = data[i];
        }
        value[0] = maxValue;
        value[1] = minValue;
        return value;
    }
// =========================================================================

    public static String getFirstToken(String line) {
        String reduced = line.trim();
        if (reduced.length() == 0) return "";
        int i;
        for (i = 0; i < reduced.length(); i++) {
            if (Character.isWhitespace(reduced.charAt(i))) break;
        }
        return reduced.substring(0, i);
    }
// =========================================================================
/*
    public static int getNumTokens(String line) {
        if (line.trim().length() == 0) return 0;
        else {
            line = line.trim();
            int i = 0;
            for ( ; i<line.length(); i++) {
                if (Character.isWhitespace(line.charAt(i))) break;
            }
            return getNumTokens(line.substring(i)) + 1;
        }
    }
//*/
// =========================================================================
//* This is the version not using recursive:
    public static int getNumTokens(String line) {
        line = line.trim();
        if (line.length() == 0) return 0;
        else {
            int k = 0;
            while (line.length() > 0) {
                int i;
                for (i = 0; i<line.length(); i++) {
                    if (Character.isWhitespace(line.charAt(i))) break;
                }
                k++;
                line = line.substring(i).trim();
            }
            return k;
        }
    }
// =========================================================================
//*/

    public static String[] shrinkArray(String[] original, int newLen){
// shrink array from the original to the size newLen, ignore the rest.
        int len = original.length;
        if (newLen >= len) return original;
        String[] newStr = new String[newLen];
        System.arraycopy(original, 0, newStr, 0, newLen);
        return newStr;
    }


// =========================================================================

    private void initialize() {

        // initialize panel for Methods:
        jCheckLD.setSelected(true);
        jCheckHet.setSelected(true);
        jCheckCoan.setSelected(true);
        jCheckTemp.setSelected(true);
//            ("Check to enter sets of generations for samples per population");
        jTextTemp.setToolTipText
                ("Sets are separated by a slash /. Each set has at least "
                + "2 generations separated by blanks or commas");

        // initialize panel for Options:
        jCheckPop.setSelected(false);
        jCheckSamp.setSelected(false);
        jTextPop.setEnabled(false);
        jTextSamp.setEnabled(false);
        jTextRange.setEnabled(false);
        jTextLocDel.setEnabled(false);

        jRadioButtonRange.setEnabled(false);
        jRadioButtonDel.setEnabled(false);
        jRadioButtonRange.setSelected(false);
        jRadioButtonDel.setSelected(true);
        jCheckLoc.setSelected(false);

        jButtonAdd.setToolTipText
                ("Add a positive number in the left textbox to the list");
        jCheckPop.setToolTipText
                ("Limit running just one population, or a range of populations");
        jCheckSamp.setToolTipText
                ("Limit number of individuals per population");
        jCheckLoc.setToolTipText
                ("Restrict loci by specifying ranges or by omitting some");
        jButtonLoci.setEnabled(false);
        // initialize panels INPUT and OUTPUT:
        jRadioButtonGen.setSelected(true);
        jCheckFileType.setSelected(true);
        jCheckName.setSelected(true);   // that is, cannot edit output name:
        jTextOutFile.setEditable(false);
        jTextFieldxLD.setEditable(false);
        jTextFieldxHet.setEditable(false);
        jTextFieldxCoan.setEditable(false);
        jTextFieldxTemp.setEditable(false);
        jTextXCrit.setEnabled(false);
        jTextFieldxLD.setEnabled(false);
        jTextFieldxHet.setEnabled(false);
        jTextFieldxCoan.setEnabled(false);
        jTextFieldxTemp.setEnabled(false);
        jTextBurrOut.setEnabled(false);
        jTextLocOut.setEnabled(false);
    // add in July 2013:
        jCheckTab.setEnabled(false);

        jTextBurrOut.setEditable(false);
        jTextLocOut.setEditable(false);
        jTextBurr.setEnabled(false);
        jTextBCrit.setEnabled(false);
        jTextLoc.setEnabled(false);
        jTextShow.setEditable(false);
        jTextMisDat.setEditable(false);
        jTextMisDat.setEnabled(false);
        // set color for uneditable textboxes for file names:
//        jTextFieldxLD.setBackground(Color.getColor("[216,228,248]"));
// set the same bakground color for the other xtra file names:
        jTextFieldxHet.setBackground(jTextFieldxLD.getBackground());
        jTextFieldxCoan.setBackground(jTextFieldxLD.getBackground());
        jTextFieldxTemp.setBackground(jTextFieldxLD.getBackground());
//        jTextBurrOut.setBackground(Color.lightGray);
//        jTextLocOut.setBackground(Color.lightGray);

//        String path = currDirectory();
        String path = currPath;
        // Initialize texts on some controls:
        if (!getIniValues(iniFileName)) {
            jTextInpFolder.setText(path);
            jTextOutFolder.setText(path);
            jTextTemp.setText(iniGen);
        // initialize panel for Critical Values:
            for (int i=0; i<critVal.length; i++) listPcrit.add(critVal[i]);
        }
        jCheckTemp.setToolTipText (tempMethod[tpMethod]);
        path = jTextInpFolder.getText();
        jTextInpFolder.setEditable(false);
        jTextOutFolder.setEditable(false);
// This is to clear the box and put items in to make appropriate size
        loadFilesToCombo(path,jComboBoxFile,endsBy,jCheckFileType.isSelected());
// Don't need to load files yet; however, should clean the box:
        jComboBoxFile.setSelectedIndex(-1);

        setToolTipTemporal();
	setToolTipPop();
	setToolTipSamp();
	setToolTipRestrictLoc();
        setToolTipCrit();
        jLabelBur2.setText("(max = " + maxPopBur + "),  and only for the top");
        jLabelLoc2.setText("(max = " + maxPopLoc + ")");
        if (jCheckCoan.isSelected() || jCheckTemp.isSelected() ||
                jCheckHet.isSelected()) {
            jCheckPcrit0.setSelected(true);
            crit0Checked = true;
        }
    }

// =========================================================================

    private void setToolTip(javax.swing.JComponent jComponent1, String tip){
        if (jComponent1.isEnabled()) jComponent1.setToolTipText(tip);
        else jComponent1.setToolTipText(null);
    }
// =========================================================================

    private void setToolTipBurTxt() {
        setToolTip(jTextBurr, tipOneRange);
        setToolTip(jTextBCrit, tipBCrit);
    }

// =========================================================================

    private void setToolTipTemporal(){
        String tipTxt = "Textbox for generation sets. Click  \" ? \" "
                + " button for a brief instruction.";
//        tipTxt = "Sets are separated by a slash /. Each set has "
//                + "at least 2 generations separated by blanks or commas";
        String tipButtonMore =
                "Click this for changing Plan and Methods";
        String tipSets = "Click this for details to input to the left textbox";
        setToolTip(jTextTemp, tipTxt);
        setToolTip(jButtonTpMethod, tipButtonMore);
        setToolTip(jButtonTemp, tipSets);
    }

// =========================================================================
// add July 2013 this setToolTipTab
    private void setToolTipTab(){
        setToolTip(jCheckTab,
        "Tab delimiter for tabular-format outputs to import into spreadsheets");
    }

    private void setToolTipPop(){
        setToolTip(jTextPop, "Range: 2 ascending numbers connected by a dash, "
                    + "one single number for 1-element range");
    }
    private void setToolTipSamp(){
        setToolTip(jTextSamp,
                "Enter the maximum number of individuals / pop to run");
    }

    private void setToolTipCrit(){
        setToolTip(jTextPcrit, "Enter a number > 0 to add (0 is intrinsic)");
    }


    private void setToolTipLocText(){
        String tipRange = "Enter ranges of loci in ascending, " +
                            "such as: 2-10, 15, 20-25";
        String tipDel = "Enter loci to be omitted, " +
                            "separated by blanks or commas";
        setToolTip(jTextRange, tipRange);
        setToolTip(jTextLocDel, tipDel);
    }

    private void setToolTipRestrictLoc(){
        String tipI = "Check to enter the range of loci";
        String tipR = "Check to enter loci to be removed, in the textbox below";
        String tipDetails = "Click this for details and info on entries";
        setToolTip(jRadioButtonRange, tipI);
        setToolTip(jRadioButtonDel, tipR);
        setToolTip(jButtonLoci, tipDetails);
        setToolTipLocText();
    }

/*

    private void setToolTipRange(boolean enabled){
        jTextRange.setToolTipText(null);
        jTextLocDel.setToolTipText(null);
        if (enabled) jTextRange.setToolTipText
                ("Enter ranges of loci in ascending, such as: 2-10, 15, 20-25");
    }

    private void setToolTipLocDel(boolean enabled){
        jTextRange.setToolTipText(null);
        jTextLocDel.setToolTipText(null);
        if (enabled) jTextLocDel.setToolTipText
                ("Enter loci to be omitted, separated by blanks or commas");
    }
//*/
// =========================================================================
    private void chooseMethod() {
        if ((jCheckLD.isSelected()) || (jCheckHet.isSelected()) ||
                (jCheckTemp.isSelected())) {
            jPanelPcrit.setEnabled(true);
            jButtonAdd.setEnabled(true);
            jButtonDel.setEnabled(true);
            jTextPcrit.setEnabled(true);
            listPcrit.setEnabled(true);
            jLabelP1.setEnabled(true);
            jLabelP2.setEnabled(true);
        } else {
            jPanelPcrit.setEnabled(false);
            jButtonAdd.setEnabled(false);
            jButtonDel.setEnabled(false);
            jTextPcrit.setEnabled(false);
            listPcrit.setEnabled(false);
            jLabelP1.setEnabled(false);
            jLabelP2.setEnabled(false);
        }
        setToolTipCrit();
    }
// =========================================================================
// no longer used
    private void showLDfile() {
        if (jCheckLD.isSelected()) {
            jCheckXtraOut.setEnabled(true);
            jCheckBurr.setEnabled(true);
            jLabelBur1.setEnabled(true);
            jLabelBur2.setEnabled(true);
            if (jCheckXtraOut.isSelected()) jTextFieldxLD.setEnabled(true);
            if (jCheckBurr.isSelected()) {
                jTextBurr.setEnabled(true);
                jTextBCrit.setEnabled(true);
                jTextBurrOut.setEnabled(true);
            }
        } else {
            jCheckXtraOut.setEnabled(false);
            jTextFieldxLD.setEnabled(false);
            jCheckBurr.setEnabled(false);
            jLabelBur1.setEnabled(false);
            jLabelBur2.setEnabled(false);
            jTextBurr.setEnabled(false);
            jTextBCrit.setEnabled(false);
            jTextBurrOut.setEnabled(false);
        }
        setToolTipBurTxt();
        setToolTip(jTextLoc, tipOneRange);
    }
// =========================================================================
    private int methodInd() {
        int n = 0;
        if (jCheckLD.isSelected()) n += 1;
        if (jCheckHet.isSelected()) n += 2;
        if (jCheckCoan.isSelected()) n += 4;
        if (jCheckTemp.isSelected()) n += 8;
        return n;
    }
// =========================================================================
    private String getSuffix() {
        String suffix;
        int n = methodInd();
        switch (n) {
            case 0:
                suffix = "";
                break;
            case 1:
                suffix = "LD";
                break;
            case 2:
                suffix = "Ht";
                break;
            case 4:
                suffix = "Cn";
                break;
            case 8:
                suffix = "Tp";
                break;
            default:
                suffix = "Ne";
                break;
        }
        return suffix;
    }

// =========================================================================
    private String outputName(String suffix) {
        String inpName = getFile(jComboBoxFile);
        String prefix = getPrefix(inpName, 0);
        if (prefix.length() == 0) return "";
        return (prefix + suffix);
    }
// =========================================================================
    private void xOutputName() {
        jTextFieldxLD.setText("");
        if (jCheckLD.isSelected()) {
            String prefix = getPrefix(jTextOutFile.getText(), 0);
            if (prefix.length() > 0) jTextFieldxLD.setText(prefix + "s" + outExt);
        }
    }
// =========================================================================
    private static boolean disableTC(Container c) {
// set the first textfield in the container c to be non-editable,
// the first comboBox having only one element
        Component[] cmps = c.getComponents();
        int n = 0;
        int k = 0;
        for (Component cmp : cmps) {
            if (cmp instanceof JTextField ) {
//                ((JTextField)cmp).setEnabled(false);
                ((JTextField)cmp).setEditable(false);
                return true;
            }
            if (cmp instanceof JComboBox && k == 0) {
                    ((JComboBox)cmp).setEnabled(false);
                k++;
                if (n == 1) return true;
            }
            if (cmp instanceof Container) {
               if (disableTC((Container) cmp)) return true;
            }
        }
        return false;
    }

// =========================================================================
    private int addToList (java.awt.List list1,
                        String toAdd, int maxsize, float low, float high) {
// add string toAdd to list1 at the correct spot to keep the list in
// descending order
        int size = list1.getItemCount();
        int i;
        String myValStr;
        if (toAdd.trim().length() == 0) return 0;
        if (getPosReal(toAdd, 0) < 0) { // not a real number
//            JFrame frame = new JFrame();
//            JOptionPane.showMessageDialog(frame,
            JOptionPane.showMessageDialog(this,
                    "Format Error for Critical Value.");
            return 2;
        }
        if (size >= maxsize) {
//            JFrame frame = new JFrame();
            JOptionPane.showMessageDialog(this,
                "Cannot add: only " + maxsize + " numbers are allowed.");
            return 2;
        }
        myValStr = roundDec(toAdd, nDecimal);
        float myVal = Float.valueOf(myValStr).floatValue();
        if (myVal <= low || myVal >= high) {
//            JFrame frame = new JFrame();
            JOptionPane.showMessageDialog(this,
                "When rounded off to " + nDecimal + " decimal places," +
                newline + "a critical value in the list must be between " +
                newline + low + " and " + high + ", exclusively.");
            return 1;
        }
        float mynum = 0;
        // if the list was empty, mynum is still 0 after the next loop
        for (i=0; i<size; i++) {
            mynum = Float.valueOf(list1.getItem(i)).floatValue();
            if (mynum <= myVal) break;
        }
        // only add if this is a new item:
        if (mynum != myVal) list1.add(myValStr, i);
        return 0;
    }

// =========================================================================

    private static String getInfoFile(String iniName, String infoNe[]) {
        int i;
        boolean newOne;
        String infoNeFile = "";
        int lineNumber = infoNe.length;
    // put a big limit of tries
        for (i=0; i<1000; i++) {
            String fullName;
            String fileName = iniName + i + ".txt";
            if (samePath)
                fullName = fileName;
//            else fullName = currPath + File.separator + fileName;
            else {
                fullName = currPath;
                if (!fullName.endsWith(File.separator))
                    fullName += File.separator;
                fullName += fileName;
            }
//            File info = new File (fullName);
            if (fileExisted(fullName)) continue;
            try {
                FileWriter fstream = new FileWriter(fullName);
                BufferedWriter out = new BufferedWriter(fstream);
                for (int j=0; j < lineNumber; j++) {
                    if (infoNe[j] == null) break;
                    out.write (infoNe[j]);
                    out.newLine();
                }
                infoNeFile = fileName;  // info file name without path
                out.close();
                break;
            } catch (IOException e) {
                return infoNeFile;
            }
        }
        return infoNeFile;
    }
// =========================================================================

    private float nextValue (String newValue, float value) {
        try {
//            NumberFormat.getInstance().parse(value);
            float myVal = Float.valueOf(newValue).floatValue();
            if (myVal >= 0 && myVal > value) {
                return myVal;
            } else {
                return value - 1.0F;
            }
//        } catch(ParseException e) {
        } catch(NumberFormatException e) {
        // Not a number.
            return value - 1.0F;
        }
    }
// =========================================================================
    private int validGeneration (String generation) {
// assume string generation is divided in blocks by blanks or/and commas.
// Return the number of blocks that represent a number, 0 if any block is
// not a valid number.
// Actually, when this is called, commas are already replaced by blanks.
        int numBlock = 0;
        char comma = ',';
        char c;
        int startInd = 0;
        int i, endInd;
        generation = generation.trim();
        int len = generation.length();
        if (len == 0) return 0;
        float value = -1.0F;
        float nextVal;
        for ( ; startInd < len; ) {
            for (i = startInd; i < len; i++) {
                c = generation.charAt(i);
                if (c != ' ' && c != comma) break;
            }
            if (i == len) break;
            // i < len, character at i is not a blank nor a comma
            for (endInd = i; endInd < len; endInd++) {
                c = generation.charAt(endInd);
                if (c == ' ' || c == comma) break;
            }
            // out of this loop, endInd is either = len, or the character at
            // endInd of the string generation is a blank or a comma.
            String newValue = generation.substring(i, endInd);
            nextVal = nextValue(newValue, value);
            if (nextVal <= value) return -1;
            numBlock++;
            value = nextVal;
            startInd = endInd;
        }
        return numBlock;
    }
// =========================================================================
    private String[] getGenerations (String generations) {
// return array of generations. If something wrong, the first element
// of the array should be the error message, which starts with letter 'E'
        int start, endInd;
        char c;
        String replaced = generations.trim();
        int len = replaced.length();
        // count the slash "/", each one is supposed to start another set
        // (if the last character is a slash, that slash is irrelevant)
        int nSets = 1;
        for (int i=0; i<len-1; i++) {
            if ('/' == replaced.charAt(i)) nSets++;
        }
        // nSets is the maximum possible for the number of sets,
        // but use lineTp to count the actual number.
        String genSet[] = new String[nSets];
        int lineTp = 0;
        for (start = 0 ; start < len; ) {
            for (endInd = start; endInd < len; endInd++) {
                c = replaced.charAt(endInd);
                if (c == '/') break;
            }
            genSet[lineTp] = replaced.substring(start, endInd).trim();
            start = endInd + 1;
            // if there is nothing between two slashes except commas,
            // then it is empty, no increment of lineTp:
            genSet[lineTp] = genSet[lineTp].replace(',', ' ');
            if (genSet[lineTp].trim().length() == 0) continue;
        // a generation set is valid if there are at least 2 generations
        // but at most 10
            int n = validGeneration(genSet[lineTp]);
            if (n <= 0) {  // not in strictly ascending order
                genSet[0] = "Error: generations at set " + (lineTp+1) +
                        " are not in ascending order";
                lineTp++;
                break;
            } else if (n == 1) {
                genSet[0] = "Error: only one generation " + genSet[lineTp] +
                            " at set " + (lineTp+1);
                lineTp++;
                break;
            } else if (n > 10) {
                genSet[0] = "Error: too many (more than 10) generations" +
                            " at set " + (lineTp+1);
                lineTp++;
                break;
            } else {    // good set, simplify it:
                // reduce to only one blank between two generations:
                genSet[lineTp] = reduceStr(genSet[lineTp], ' ');
//System.out.println("GenSet revised = " + genSet[lineTp]);
            }
            lineTp++;
        }
        if (lineTp == 0) { // empty in jTextTemp
            genSet[0] = "Error: No information on generations.\n";
            lineTp++;
        }
        String genInfo[] = new String[lineTp];
        System.arraycopy(genSet, 0, genInfo, 0, lineTp);
        return genInfo;
    }

// =========================================================================
    private String[] getGenerations (String generations, int plan) {
// return array of generations. If something wrong, the first element
// of the array should be the error message, which starts with letter 'E'
        int start, endInd;
        char c;
        char colon = ':';
        String replaced = generations.trim();
        int len = replaced.length();
        // count the slash "/", each one is supposed to start another set
        // (if the last character is a slash, that slash is irrelevant)
        int nSets = 1;
        for (int i=0; i<len-1; i++) {
            if ('/' == replaced.charAt(i)) nSets++;
        }
        // nSets is the maximum possible for the number of sets,
        // but use lineTp to count the actual number.
        String genSet[] = new String[nSets];
        int lineTp = 0;
        int n0 = 0; // this stands for the census population size.
        // Should be assigned 0 for Plan II and read in or re-assigned from
        // previous set. This is referred as N in the comments in the next loop
        String generation = ""; // store generation values
        for (start = 0 ; start < len; ) {
            for (endInd = start; endInd < len; endInd++) {
                c = replaced.charAt(endInd);
                if (c == '/') break;
            }
            genSet[lineTp] = replaced.substring(start, endInd).trim();
            start = endInd + 1;
            // if there is nothing between two slashes except commas,
            // then it is empty, no increment of lineTp:
            genSet[lineTp] = genSet[lineTp].replace(',', ' ');
            genSet[lineTp] = genSet[lineTp].trim();
            if (genSet[lineTp].length() == 0) continue; // empty set
            // next, find the first, if any, colon in this set
            int i = genSet[lineTp].indexOf(colon);
            int n;
            if (i >= 0) {
                // One colon exists in this set. Make sure it is the only one
                n = genSet[lineTp].substring(i+1).indexOf(colon);
                if (n >= 0) {
                    genSet[0] = "Error: More than one colon at set " +
                            (lineTp+1) + " (only one is allowed)";
                    lineTp++;
                    break;
                }
                // now only one colon in the set.
                // For plan 2, there should be only one colon, nothing else;
                // if this is viloated, it is considered as an error.
                if (plan == 1) {
                    n = getNumTokens(genSet[lineTp].substring(0,i)) +
                            getNumTokens(genSet[lineTp].substring(i+1));
                    if (n > 0) {
                        if (lineTp == 0) genSet[0] = "Error, Plan II: " +
                                "no colon allowed in set 1";
                        else genSet[0] = "Error, Plan II: if colon is entered "
                                + "at set " + (lineTp+1) +
                                " for repetition, then nothing else allowed.";
                        lineTp++;
                        break;
                    }
                    // now, n = 0: only one colon between slashes, so this
                    // set is a repetition of the previous one.
                    // Error if this is the first set, i.e. lineTp = 0.
                    if (lineTp == 0) {
                        genSet[0] = "Error: No previous set to repeat. "
                                + "Set 1 must be entered!";
                        lineTp++;
                        break;
                    }
                    // the set is legitimate: a repetition of previous one,
                    // so the String variable 'generation' is unchanged.
                    genSet[lineTp] = genSet[lineTp-1];
                } else {    // Plan I
                // since genSet[lineTp] has no leading blanks,
                // there should be some token in front of the colon if i > 0.
                    String front = genSet[lineTp].substring(0,i);
                    String back = genSet[lineTp].substring(i+1);
                    n = getNumTokens(front);
                    int m = getNumTokens(back);
                    // n is the number of tokens before the colon,
                    // m is the number of tokens after the colon
                    if ((m == 0 || n == 0) && lineTp == 0) {
                        genSet[0] = "Error: No previous set to repeat. "
                                + "Set 1 must be fully entered!";
                        lineTp++;
                        break;
                    }
                    if (n == 0) {   // Census population N for this set is
                    // the same as N in the previous set. Here lineTp > 0.
                    // No change for n0.
                        if (m == 0) // the whole generation set is repeated,
                            // no change in variable 'n0', nor in 'generation'
                            genSet[lineTp] = genSet[lineTp-1];
                        else  {  // N repeated, but generations were entered
                            // which will be tested later for legitimacy.
                            generation = back.trim();
                            genSet[lineTp] = n0 + " " + generation;
                        }
                    } else {    // n > 0. If m = 0, lineTp must be > 0
                        if (n == 1) {   // one token, make sure it is > 0
                            int k = getPositiveInt(front);
                            if (k <= 0) {   // error
                                genSet[0] = "Error: Census population size N"
                                            + " must be positive in Plan I.";
                                lineTp++;
                                break;
                            }
                            // this set is legitimate for the first entry
                            n0 = k;
                            // now check for m: if m = 0, generations are
                            // repeated (lineTp then > 0, so previous
                            // generations were entered, 'generation' unchanged.
                            if (m == 0) genSet[lineTp] = n0 + " " + generation;
                            else {
                                generation = back.trim();
                                genSet[lineTp] = n0 + " " + generation;
                            }
                        } else {    // more than one token in front of colon
                            genSet[0] = "Error: more than one entry entered "
                                        + "for census population N at set "
                                        + (lineTp+1) + ".";
                            lineTp++;
                            break;
                        }   // end of the case that the number of
                        // tokens in front of the colon is > 0, for Plan I
                    }   // end all cases on the number of tokens in front
                        // of the colon, for plan I

                }   // end of cases when there is a colon, both Plans I and II.
            } else {    // else is the case when there is no colon, so the
                // whole set is for generations, which are not empty since
                // empty set was skipped already.
                if (plan == 0) {   // Plan I, N is assumed previous value
                    if (lineTp == 0) {
                        genSet[0] = "Error, Plan I: Census size N followed"
                                + " by a colon must be entered at set 1.";
                        lineTp++;
                        break;
                    }
                    generation = genSet[lineTp];
                    genSet[lineTp] = n0 + " " + genSet[lineTp];
                } else {    // Plan II
                    generation = genSet[lineTp];
                    genSet[lineTp] = n0 + " " + genSet[lineTp];
                }
            }
//System.out.println(genSet[lineTp] + ", generation = " + generation);
        // a generation set is valid if there are at least 2 generations
        // but at most 10
            n = validGeneration(generation);
            if (n < 0) {  // not in strictly ascending order
                genSet[0] = "Error: generations at set " + (lineTp+1) +
                        " are not in ascending order";
                lineTp++;
                break;
            } else if (n == 0) { // empty
                genSet[0] = "Error: generations at set " + (lineTp+1) +
                        " are not given";
                lineTp++;
                break;
            } else if (n == 1) {
                genSet[0] = "Error: only one generation " + genSet[lineTp] +
                            " at set " + (lineTp+1);
                lineTp++;
                break;
            } else if (n > 10) {
                genSet[0] = "Error: too many (more than 10) generations" +
                            " at set " + (lineTp+1);
                lineTp++;
                break;
            } else {    // good set, simplify it:
                // reduce to only one blank between two generations:
                genSet[lineTp] = reduceStr(genSet[lineTp], ' ');
//System.out.println("GenSet revised = " + genSet[lineTp]);
            }
            lineTp++;
        }
        if (lineTp == 0) { // empty in jTextTemp
            genSet[0] = "Error: No information on generations.\n";
            lineTp++;
        }
        // if the tails of the array genSet are identical, reduce the array
        // size to copy into the returning array
        boolean same = true;
        while (same && (lineTp > 1)) {
            if (genSet[lineTp-1].equals(genSet[lineTp-2])) lineTp--;
            else same = false;
        }
        String genInfo[] = new String[lineTp];
        System.arraycopy(genSet, 0, genInfo, 0, lineTp);
        return genInfo;
    }

// =========================================================================
    private String[] collectInfo(boolean showDir) {
    // only called when entries are already checked good (by goodEntries)
        int basicLine = 10; // basic lines = 9, add 1 for comment line
        int nSets = 0;
        int lineTp = 0;
        int line = 0;
        int start, endInd;
        int method = methodInd();
        // if no critical values, basicLine is less:
        if (listPcrit.getItemCount() == 0) basicLine--;
        if (method >= 8) {
            String generations = jTextTemp.getText().trim();
//            String genSet[] = getGenerations (generations);
            String genSet[] = getGenerations (generations, tPlan);
            lineTp = genSet.length;
            basicLine += lineTp + 1; // need an extra line to stop generations
        }
        String info[] = new String[basicLine];
        for (int i = 0; i < basicLine; i++) info[i] = "";
        if (method <= 0) {
            String msg = "No method was chosen!";
            JOptionPane.showMessageDialog(this, msg);
            return info;
        }
//        String path = currDirectory();
        String path = currPath;
        // want to compare currPath with pathIn (read from jTextInpFolder)
        // without file separator that might be at the end
        int n = path.length();
        if (path.charAt(n-1) == File.separatorChar)
            path = path.substring(0, n-1);
        info[line] = Integer.toString(method);
        if (method >= 8) {
            info[line] += "   " + tpMethod;
            info[line] += "  \t* First number n = sum of method(s)" +
                " to run: LD(=1), Het(=2), Coan(=4), Temporal(=8). " +
                "Second number k is for various temporals; see below";
        } else info[line] += "  \t* A number = sum of method(s) " +
                "to run: LD(=1), Het(=2), Coan(=4), Temporal(=8).";
        line++;
        // directory: if current directory, empty string
        String pathIn = jTextInpFolder.getText().trim();
        n = pathIn.length();
        if (pathIn.charAt(n-1) == File.separatorChar)
            pathIn = pathIn.substring(0, n-1);
//        if (path.equals(pathIn)) {
        if (path.equals(pathIn) && samePath && (!showDir)) {
            info[line] = " \t\t\t* Input directory is current directory";
        } else {
            info[line] = pathIn + File.separatorChar + " \t* Input Directory";
        }
        line++;
        String inpFile = getFile(jComboBoxFile);
        info[line] = inpFile + " \t* " + "Input file name";
        line++;
        if (jRadioButtonGen.isSelected()) {
            info[line] = "2";
        } else {
            info[line] = "1";
        }
        info[line] += " \t\t\t* 1 = FSTAT format, 2 = GENEPOP format";
        line++;
        String pathOut = jTextOutFolder.getText();
        n = pathOut.length();
        if (pathOut.charAt(n-1) == File.separatorChar)
            pathOut = pathOut.substring(0, n-1);
//        if (path.equals(pathOut)) {
        if (path.equals(pathOut) && samePath && (!showDir)) {
            info[line] = " \t\t\t* Output directory is current directory";
        } else {
            info[line] = pathOut + File.separatorChar + " \t* Output Directory";
        }
        line++;
        String outFile = jTextOutFile.getText().trim();
        if (jCheckAppend.isSelected()) outFile += "*";
        info[line] = outFile +
        " \t* Output file name (put asterisk adjacent to the name to append)";
        line++;
        int k = listPcrit.getItemCount();
        if (method == 4) k = 0;  // Coancestry: no critical value
        info[line] = k + " \t\t\t* Number of critical values";
        line++;
        if (k > 0) {
            info[line] = "";
            for (int i=0; i<k; i++) {
                info[line] += listPcrit.getItem(i) + "  ";
            }
            if (!jCheckPcrit0.isSelected()) info[line] += "-1 ";
            info[line] += " \t* Critical values";
            line++;
        }
        info[line] = randLD + " \t\t* 0: Random mating, 1: Monogamy (LD method)";
/*
        info[line] = "0"; // default: no restriction on number of pop.
        if (jCheckPop.isSelected()) {
            String popVal = jTextPop.getText().trim();
            info[line] = recPopRange(popVal);
//            info[line] = popVal;
        }
        info[line] += " \t* Up to population, or range of populations to run" +
                " (if 2 entries); <= 0 for no restriction";
*/
        line++;
        // the rest are for generations in temporal method.
        // each string must end with at least a blank followed by an asterisk.
        // The next if was done before, variables in there are local,
        // so need to do it again.
        if (method >= 8) {
            String generations = jTextTemp.getText().trim();
//            String genSet[] = getGenerations (generations);
            String genSet[] = getGenerations (generations, tPlan);
            for (int i = 0; i < lineTp; i++) {
                info[line] = genSet[i] + " \t* One set of generations " +
                        "per line. The first entry is N > 0 for plan I, 0 for "
                        + "plan II. Then generations follow.";
                line++;
            }
            info[line] = "0 \t\t* Only 0 entered: End of generations input";
            line++;
        }
        info[line] = newline + "* Input/Output directories should be ended by" +
                " a separator: '" + File.separator + "'." + newline +
                "  If the directory contains the executable " + exeName +
                ", it may be left empty." + newline + newline +
                "* An asterisk after a blank may be used to signal the end" +
                " of data" + newline + "  on the line. It is not required." +
                newline + newline + "* Line 1 may contain 2 entries n, k, " +
                "whene n is for which methods." + newline + "  If n < 8, then "
                + "no Temporal method, and k is ignored if entered." +
                newline + "  If n >= 8, then k is to limit temporal to one" +
                " or more of the 3 methods," + newline +
                "  by taking the sum" + newline +
                "\tPollak = 1, Nei/Tajima = 2, Jorde/Ryman = 4." + newline +
                "  \t(May enter k = 0 for all temporal methods.)"
                + newline + newline + "* Line 7 contains n = number of" +
                " positive critical values to be read."
                + newline + "  If n > 0, the next line should contain n "
                + "positive critical values." + newline +
                "  Critical value 0 is automatically added, unless" +
                " a negative value" + newline +
                "  is entered after the last value. If a negative is inserted"
                + newline + "  before the last value, entries for critical " +
                "values end there." + newline +
                "  The same effect if an asterisk is put immediately" +
                " after the last value." + newline + newline + "* Generations "
                + "(excluding entry N) should be given in ascending order." +
                newline + "  If not, an asterisk should be put adjacent to" +
                " the last entry.";

        return info;
    }
// =========================================================================
// NO LONGER USED, replaced by getPositiveInt
    private int takePositiveInt (String value) {
    // return the integer value. If string value is empty, return -1.
    // return -2 if it is a negative integer, - 3 if value is not an integer
        value = value.trim();
        if (value.length() == 0) return -1;
        try {
            int num = Integer.parseInt(value);
            if (num >= 0) {
                return num;
            } else return -2;
        } catch (NumberFormatException e) {
        // not an integer
            return -3;
        }
    }
// =========================================================================
    private String[] collectOption() {
    // this is called when the entries are already checked (by goodEntries)
        int size = 10;
        String option[] = new String[size];
        for (int i = 0; i < size; i++) option[i] = "";
        int n = 0;
        if (jCheckXtraOut.isSelected()) n = methodInd();
        option[0] = Integer.toString(n);
//        if (n >= 8) option[0] += "  " + tpMethod;
// add second entry, no matter temporal in place or not, so that the
// option for PCrits can be entered (if not default, PCrit option should
// be the third entry
        if (jCheckTemp.isSelected()) option[0] += "  " + tpMethod + "  ";
        else option[0] += "  0  ";
// if there is option for PCrits:
        if (jCheckXtraOut.isSelected()) {
            option[0] += jTextXCrit.getText();
            if (jTextXCrit.getText().trim().length() == 0)
                option[0] += (listPcrit.getItemCount() + 1);
            if (jCheckTab.isSelected()) option[0] += "  1";
            else option[0] += "  0";
        }
        option[0] +=
            " \t* First number = sum of method(s) to have extra output: "
                + "LD(=1), Het(=2), Coan(=4), Temporal(=8)";
        option[1] = "0";
        if (jCheckSamp.isSelected()) option[1] = jTextSamp.getText().trim();
        option[1] += " \t* Maximum individuals/pop. If 0: no limit";
        option[2] = "0";
        if (jCheckLocOut.isSelected()) {
            String nPop = jTextLoc.getText().trim();
            option[2] = recPopRange(nPop);
        }
        option[2] +=
                " \t* First entry n1 = 0: No Freq output. If n1 = -1:" +
                " Freq. output up to population " + maxPopLoc +
                ". Two entries n1, n2 with n1 <= n2: Freq output for " +
                "populations from n1 to n2." +
                " Max. populations to have Freq output is set at " + maxPopLoc;
        option[3] = "0";
        if (jCheckBurr.isSelected()) {
            String nPop = jTextBurr.getText().trim();
            option[3] = recPopRange(nPop) + " " + jTextBCrit.getText();
            if (jTextBCrit.getText().trim().length() == 0)
                option[3] += (listPcrit.getItemCount() + 1);
        }
        option[3] += " \t* For Burrow output file (up to " +
                maxPopBur + " populations can have output)." +
                " See remark below";

        option[4] = hasCI + " \t* Parameter CI: 1 for Yes, 0 for No";
        option[5] = hasCI + " \t* Jackknife CI: 1 for Yes, 0 for No";


//        option[6] = randLD + " \t* 0: Random mating, 1: Monogamy (LD only)";

        option[6] = "0"; // default: no restriction on number of pop.
        if (jCheckPop.isSelected()) {
            String popVal = jTextPop.getText().trim();
            option[6] = recPopRange(popVal);
//            option[6] = popVal;
        }
        option[6] += " \t* Up to population, or range of populations to run" +
                " (if 2 entries). If first entry = 0: no restriction";


        if (jCheckLoc.isSelected()) {
            if (jRadioButtonRange.isSelected()) {
                String locRange = jTextRange.getText().trim();
//                locRange = locRange.replace('-', ' ');
                locRange = finalRanges(locRange);
                option[7] = locRange +
                        " \t* Ranges of loci to be used, in pairs";
            } else {
                String locDel = revisedLocDel(jTextLocDel.getText(), false);
    //            option[7] = "" + goodLocDel(jTextLocDel.getText().trim());
    //            option[7] += " \t* Number of loci to be omitted";
    //            option[8] = jTextLocDel.getText().trim().replace(',', ' ');
                option[7] = getNumTokens(locDel) +
                        " \t* Number of loci to be omitted";
                option[8] = locDel + " \t* Loci omitted";
            }
        } else option[7] = "0 \t* All loci are accepted";
        // Begin writing remarks:
        option[9] = "* Line 8 should contain info on loci restriction, "
                + "0 is for no restriction."
                + newline + "  If only one number is given, it is the number "
                + "of loci to be omitted, then" + newline + "  the next line(s)"
                + " should list omitted loci (ended by a non-digit character)."
                + newline + "  If more than one entry are entered on line 8, "
                + "then they should be entered" + newline + "  in pairs on the"
                + " same line, each pair is for a range of loci to be included."
                + newline + "  Examples:\tpair 2 5 is for loci from 2 to 5;"
                + " pair 9 9 is for locus 9." + newline;
        option[9] += newline + "* Line 4: Up to 3 entries can be entered for "
                + "Burrows output." + newline + "  If the first entry n1 = 0: "
                + "NO Burrows output, the rest are ignored." + newline
                + "  If n1 = -1: all populations up to population " + maxPopBur
                + " to have Burrows output." + newline
                + "  Two entries n1, n2 (0 < n1 <= n2): Burrows output for"
                + " the range of" + newline + "  populations from n1 to n2. " +
                "Maximum " + maxPopBur + " populations can have Burrows output."
                + newline + newline
                + "  The next entry m (after n1 = -1, or after n1, n2) is for"
                + " the number of" + newline
                + "  critical values, counting from the highest,"
                + " to have Burrows output." + newline
                + "  (If m = 0, only the smallest critical value, "
                + "usually 0, is outputted)."
                + newline;
        option[9] += newline + "* Line 1 (Tabular-format outputs): " +
                "If the first entry includes Temporal (>= 8)," +
                newline + "  the second entry is to limit temporal output" +
                " to one or more of the 3 methods:" + newline +
                "\tPollak = 1, Nei/Tajima = 2, Jorde/Ryman = 4." + newline +
                "  If the second entry is 0, or is at least 7, or absent: " +
                "extra output has all" + newline + "  temporals shown in " +
                "the main output. This is the default." + newline +
                "  > Third entry C (the second must be entered even no "+
                "Temporal) is for the" + newline + "  number of highest " +
                "critical values to be outputted in tabular-format outputs." +
                newline + "  (If C = 0, only the smallest critical value, " +
                "usually 0, is outputted.)" + newline +
                "  If C is at least the number of critical values" +
                " including 0 (e.g. C = " + (maxListSize+1) + ")," + newline +
                "  then all critical values are included in tabular-format " +
                "outputs." + newline +
                "  > Fourth entry F is for Tab delimiter (entry C as " +
                "described above must be" + newline + "  entered). F = 0:" +
                " no Tab delimiter. F > 0: Tab delimiter in these outputs." +
                newline + "  (If no F is given, default F = 0.)" +
                newline +  newline +
                "  Extra Outputs cannot contain more methods than the main" +
                " output," + newline + "  so the two entries here may be " +
                "superseded by entries for main output." + newline +
                "  If temporal is desired for extra output, at least one " +
                "temporal method" + newline + "  must be present; so if " +
                "second entry causes such error [NOT picking any" + newline  +
                "  method that is included in the main output], " +
                "default will take place.";
        return option;
    }

// =========================================================================
    private boolean hasInputOutput() {
        String errMsg = "";
        String inpFile = getFile(jComboBoxFile);
        int err = 0;
        if (inpFile.length () == 0) {
            err++;
            errMsg += "No Input File is given!";
        }
        String outFile = jTextOutFile.getText().trim();
        if (outFile.length() == 0) {
            if (err > 0) errMsg += "\n";
            err++;
            errMsg += "No Output File is given!";
        }
        if (methodInd() == 0) {
            if (err > 0) errMsg += "\n";
            err++;
            errMsg += "No method is given!";
        }
        if (err > 0) {
//            JFrame frame = new JFrame();
            JOptionPane.showMessageDialog(this, errMsg);
            return false;
        }
        // from now, err = 0: input and output file names are not empty.
        String pathIn = jTextInpFolder.getText();
        String pathOut = jTextOutFolder.getText();
        if (pathIn.equals(pathOut) && inpFile.equalsIgnoreCase(outFile)) {
            errMsg = "Input and Output are identical (case-insensitive)!";
//            JFrame frame = new JFrame();
            JOptionPane.showMessageDialog(this, errMsg, "Output error", 0);
            return false;
        }
        if ((!jCheckXtraOut.isEnabled()) || (!jCheckXtraOut.isSelected()))
            return true;
        outFile = jTextFieldxLD.getText().trim();
        if (pathIn.equals(pathOut) && inpFile.equalsIgnoreCase(outFile)) {
            errMsg = "Input and Extra Output are identical (case-insensitive)!";
//            JFrame frame = new JFrame();
            JOptionPane.showMessageDialog(this, errMsg, "Output error", 0);
            return false;
        }
        return true;
    }
// =========================================================================
    private int gotInt (String value) {
        int myVal;
        try {
            myVal = Integer.parseInt(value.trim());
        } catch (NumberFormatException e) {
            myVal = 0;
        }
        return myVal;
    }

// =========================================================================
// NO LONGER USED
    private boolean goodRange(String range) {
// A legitimate range consists of two integers in ascending order,
// which can be separated by a dash and/or blanks (a dash is not required)
// (Can have multiple dashes.)
        int n = range.length();
        int i;
        String replace = range.replace('-', ' ').trim();
        for (i = 0; i < n; i++) {
            if (replace.charAt(i) == ' ') break;
        }
        if (i < n) {
            String num1 = replace.substring(0,i);
            String num2 = replace.substring(i+1);
            int k1, k2;
            try {
                k1 = Integer.parseInt(num1.trim());
                k2 = Integer.parseInt(num2.trim());
                if (k1 <= 0 || k2 <= 0) return false;
                // the range should have at least two loci:
                if (k1 >= k2 - 1) return false;
            } catch (NumberFormatException e) {
            // one of them is not an integer
                return false;
            }
        } else return false;
        return true;
    }
// =========================================================================
// NO LONGER USED

    private int goodLocDel(String locSet) {
        locSet = locSet.trim();
        int len = locSet.length();
        int value = 0;
        int nextVal;
        int startInd = 0;
        char comma= ',';
        int n = 0;
        for ( ; startInd < len; ) {
            int i, endInd;
            char c;
            for (i = startInd; i < len; i++) {
                c = locSet.charAt(i);
                if (c != ' ' && c != comma) break;
            }
            if (i == len) break;
            // i < len, character at i is not a blank nor a comma
            for (endInd = i; endInd < len; endInd++) {
                c = locSet.charAt(endInd);
                if (c == ' ' || c == comma) break;
            }
            // out of this loop, endInd is either = len, or the character at
            // endInd of the string generation is a blank or a comma.
            String newValue = locSet.substring(i, endInd).trim();
            if (newValue.length() == 0) {
                startInd = endInd;
                continue;
            }
            try {
                nextVal = Integer.parseInt(newValue);
                if (nextVal <= value) return 0;
                else n++;
            } catch (NumberFormatException e) {
        // not an integer
                return 0;
            }
            value = nextVal;
            startInd = endInd;
        }
        return n;
    }
// =========================================================================

    private String revisedLocDel(String locSet, boolean checked) {
        // replace commas by blanks in locSet, reorder locSet so that
        // entries are strictly increasing, and spaced by one blank
        locSet = locSet.replace(',', ' ');
        locSet = locSet.trim();
        int len = locSet.length();
        if (len == 0) return "";
        // check if all tokens are positive integers:
        int i, m, n;
        int nTokens = getNumTokens(locSet); // this should be > 0.
        // Make a reduced string from locSet by combining all
        // white spaces between consecutive tokens into one blank,
        // and check for error: all tokens must be positive integer
        // within the max allowed, which is the constant maxInt.
        // Only need do this when this locSet was not checked.
        String token;
        String reduced = locSet;
        if (!checked) {
            reduced = "";
            for (i=0; i< nTokens; i++) {
                if (i > 0) reduced += " ";
                token = getFirstToken(locSet);
                int value = getPositiveInt(maxInt, token);
                if (value <= 0) {
                // if "token" for a number is too long, limit its showing:
                // (unlike in range, can have blank following dots: ...)
                    if ((m=token.length()) > 10)
                        token = "... " + token.substring(m-10, m);
                    reduced = token + " < Error at entry " + (i+1);
                    return reduced;
                }
                // token may have leading zeros, so use its value instead:
                reduced += value;
                n = token.length();
                locSet = locSet.substring(n).trim();
            }
        }
        // now reduced contains all tokens in locSet, one blank between
        // consecutive tokens. Next, find the smallest value in reduced:
        int nextVal;
        int n1 = 0, n2 = 0; // used to keep track the index of character
        // starting token and the index of character after ending token,
        // the token that yields the smallest value so far
        token = getFirstToken(reduced);
        int value = getPositiveInt(token);
        int n0 = token.length();
        n = n0;
         // there is a blank at index n, after the first token, so need to trim
        String remain = reduced.substring(n).trim();
//System.out.println("checked = " + checked);
//System.out.println("before the loop, " + value + ", nTokens = " + nTokens +
//", reduced = " + reduced + ", remain = " + remain);
        for (i = 1; i < nTokens; i++) {
            n++;  // since there is at least one more token, this is index
                    // of the start of the next token (in reduced)
            String nextToken = getFirstToken(remain);
            nextVal = getPositiveInt(nextToken);
            m = nextToken.length();
//int k = value;
            if (nextVal < value) {  // this is smallest so far
                n1 = n;
                n2 = n + m; // index at the blank after the end of nextToken
                        // (or the length of reduced if it ends at nextToken)
                value = nextVal;
            }
//System.out.println("at i = " + i + ", remain = " + remain +
//", smallest so far = " + k + ", nextVal = " + nextVal);
            n += m;  // regardless of the previous condition
            remain = remain.substring(m).trim();
//System.out.println ("         for next i, remain = " + remain);
        }
        if (n1 < n2) {
            token = reduced.substring(n1, n2);
            // There is a blank before index n1, and at index n2, so we trim:
            String nextOne = reduced.substring(0, n1).trim() + " " +
                    reduced.substring(n2).trim();
            //
//System.out.println("Next loop is for '" + nextOne + "'");
            value = getPositiveInt(token);
            // the reason to use value, instead of token, is that token
            // may have redundant leading zeros
            reduced = value + " " + revisedLocDel(nextOne, true);
//            reduced = token + " " + revisedLocDel(nextOne, true);
        } else {    // the first one is smallest, so arrange the rest
            String nextOne = reduced.substring(n0).trim();
            reduced = value + " " + revisedLocDel(nextOne, true);
//            reduced = token + " " + revisedLocDel(nextOne, true);
//System.out.println("Next loop is for '" + nextOne + "'");
        }
        reduced = reduced.trim();  // need to trim the extra blank at the end
        nTokens = getNumTokens(reduced);
        // now, reduced is in ascending order, need to remove extras
        // so that it becomes strictly increasing. Since this is recursive,
        // only need to combine the first two:
        if (nTokens >= 2) {
            token = getFirstToken(reduced);
            remain = reduced.substring(token.length()).trim();
            value = getPositiveInt(token);
            token = getFirstToken(remain);
            if (value == getPositiveInt(token)) reduced = remain;
        }
// System.out.println("Result =  '" + reduced);
        return reduced;
    }

// =========================================================================
    private static String convRange(String range, int maxSize) {
    // some code here is redundant, because at input range will not contain,
    // blanks and will not contain only dashes (dash will be erased
    // if no number left in textbox for population range).
    // Also range will not start with a dash, only starts with a number.
    // Return "E" if error: more than 2 numbers, or the first one is 0.
    // if no error, return simplified range (no dash, at most 1 blank)
        String revised = range.trim();
        if (revised.length() == 0) return "";   // range is empty
        int n;
        if (revised.indexOf('-') != -1) {   // there is a dash, so at least
            // 2 numbers should be in string range
            revised = revised.replace('-', ' ');
            n = getNumTokens(revised);
            if (n == 1) return "E";
        } else n = 1;
        if (n == 0 || n > 2)    // n = 0: only dash (not going to happen)
            return "E";         // n > 2: more than 2 numbers in range
        // the rest: string revised contains 1 or 2 tokens, i.e., n = 1 or 2.
        String token = getFirstToken(revised);
        int first = getPositiveInt(token);
        if (first == 0) return "E";
        if (n == 1) return token;
        int second = getPositiveInt(revised, 1);
        if (second < first) return "E";
        if (first + maxSize <= second) second = first + maxSize -1;
        revised = token + " " + second;
        return revised;
    }
// =========================================================================

    private int checkPopRange(JTextField jTextField1, int maxSize)
    {
        String popRange = convRange(jTextField1.getText().trim(), maxSize);
        // popRange either has no blank, or exactly one blank between 2 numbers
        if (popRange.equals("E")) return 1;
//        jTextField1.setText(popRange.replace(' ', '-'));
        return 0;
    }
// =========================================================================
    private String recPopRange(String range) {
    // convert range to a string to put in Option file, called by collectOption
    // The return string should be in accordance with the way Ne prog reads
    // for populations to output to Freq. data file or Burrow file.
    // On input, range is either (according to the instruction to enter in
    // textboxes for population range, and by adjustment from checkPopRange):
    //      * empty, to represent no limit on populations,
    //      * a single number N, to represent only population N
    //      * a range of the form "m-n" or "m n" where m, n are numbers, m <= n.
//        String toRec = "";
        if (range.trim().length() == 0) return ("-1");
        // this is actually unnecessary, since the dash was removed beforehand
        String revised = range.replace('-', ' ');
        int n = getNumTokens(revised);  // n should be either 1 or 2
        String token = getFirstToken(revised);
        if (n == 1) return (token + " " + token);
//        int first = getPositiveInt(revised, 0); // should be > 0
//        int second = getPositiveInt(revised, 1);    // =0 if n=1, else >= first
//        if (first == 1) toRec = Integer.toString(second);
        return revised;
    }
// =========================================================================
    private boolean goodEntries() {
    // check if user inputs on the form are correct.
    // This is called before isGoodToGo, so at this time, it doed not have
    // info on number of pops, of loci.
        int err = 0;
        String errMsg = "";
        // for error in textbox for temporal, and textboxes in options:
        int tempErr = 0, popErr = 0, sampErr = 0, locErr = 0;
        int popBurr = 0, popLoc = 0;
        int popStart = 1;
        int popEnd = 0;
//        if (checked) popEnd = numPop;
        // add these to update numPop and numLoci -------------------------
        // This added thing may be repeated at another method as
        // it is called together with this method (so, some redundancy here!)
        String fileName = getFile(jComboBoxFile);
        String path = jTextInpFolder.getText().trim();
        if (currPath.equals(path) && samePath) path = "";
        else path += File.separatorChar;
        if (jRadioButtonGen.isSelected()) numLoci = getGenLoci(path, fileName);
        else numLoci = getFstatLoci(path, fileName);
        popEnd = numPop;
        popToRun = numPop;
        locToRun = numLoci;
        // ----------------------------------------------------------------
        // Begin: check generations (temporal):
        if (methodInd() >= 8) {
            String generations = jTextTemp.getText().trim();
//        String genSet[] = getGenerations (generations);
            String genSet[] = getGenerations (generations, tPlan);
            if (genSet[0].charAt(0) == 'E') {
                if (err > 0) errMsg += newline;
                err += 1;
                errMsg += genSet[0];
                tempErr = 1;
            }
        }
        // check pop option:
        if (jCheckPop.isSelected()) {
            if ((popErr = checkPopRange(jTextPop, 0)) > 0) {
                if (err > 0) errMsg += newline;
                err++;
                errMsg += "Invalid entry for population " +
                        "(or range of populations) to run Ne.";
            } else {    // get range to check with Burrow, Freq. outputs
                String popRange = recPopRange(jTextPop.getText().trim());
                if (!popRange.equals("-1")) {
                    int i = getPositiveInt(popRange, 0);
                    int j = getPositiveInt(popRange, 1);
                // check with input file
                    // popEnd = numPop if there is info on input, 0 otherwise
                    if (popEnd > 0) popErr = (i > popEnd)? 1: 0;
                    popStart = i;
                    if (j < popEnd) popEnd = j;
                    popToRun = popEnd - popStart + 1;
                    if (popToRun < 0) popToRun = 0;
                    if (popToRun > numPop) popToRun = numPop;
                    if (popErr == 1) {
                        if (err > 0) errMsg += newline;
                        err++;
                        errMsg += "Invalid entry for population "
                            + "(or range of populations) to run Ne." + newline
                            + "Number of populations in input file = " + numPop;
                    }
                }
            }
//            String popVal = jTextPop.getText().trim();
//            if (getPositiveInt (popVal) <= 0) {
//                if (err > 0) errMsg += newline;
//                err++;
//                popErr = 1;
//                if (popVal.length() == 0)
//                    errMsg += "Maximum population is chosen, but not entered.";
//                else
//                    errMsg += "Invalid entry for maximum population.";
//            }
        }
        // check for Burrow and Frequency outputs;
        if (jCheckBurr.isSelected() && jCheckBurr.isEnabled()) {
//            if (checkPopVal(jTextBurr) > 0) {
            if ((popBurr = checkPopRange(jTextBurr, maxPopBur)) > 0) {
                if (err > 0) errMsg += newline;
                err++;
                errMsg += "Invalid entry for population " +
                        "(or range of populations) for Burrow output.";
            } else if (popErr == 0) {   // population range to run is OK,
                // need to check if there is a conflict:
                if (popEnd > 0) { // = 0 when there is no need to check
                    String range = recPopRange(jTextBurr.getText().trim());
                    if (!range.equals("-1")) {
                        int i = getPositiveInt(range, 0);
                        int j = getPositiveInt(range, 1);
                        popBurr = ((j < popStart) || (i > popEnd))? 1: 0;
                    }
                    if (popBurr == 1) {
                        if (err > 0) errMsg += newline;
                        err++;
                        errMsg += "Population (or range of populations) " +
                            "for Burrow output is not designated to run.";
                    }
                }   // end of "else if (popErr == 0)"
            }
        }   // end of "(jCheckBurr.isSelected() && jCheckBurr.isEnabled())"
        if (jCheckLocOut.isSelected()) {
//            if (checkPopVal(jTextLoc) > 0) {
            if ((popLoc = checkPopRange(jTextLoc, maxPopLoc)) > 0) {
                if (err > 0) errMsg += newline;
                err++;
                errMsg += "Invalid entry for population " +
                        "(or range of populations) for Frequency output.";
            } else if (popErr == 0) {   // population range to run is OK,
                // need to check if there is a conflict:
                if (popEnd > 0) { // = 0 when there is no need to check
                    String range = recPopRange(jTextLoc.getText().trim());
                    if (!range.equals("-1")) {
                        int i = getPositiveInt(range, 0);
                        int j = getPositiveInt(range, 1);
                        popLoc = (j < popStart || i > popEnd)? 1: 0;
                    }
                    if (popLoc == 1) {
                        if (err > 0) errMsg += newline;
                        err++;
                        errMsg += "Population (or range of populations) " +
                            "for Freq. output is not designated to run.";
                    }
                }   // end of "else if (popErr == 0)"
            }
        }
        if (jCheckSamp.isSelected()) {
            String nSamp = jTextSamp.getText().trim();
            if (getPositiveInt(nSamp) <= 0) {
                if (err > 0) errMsg += newline;
                err++;
                sampErr = 1;
                if (nSamp.length() == 0)
                    errMsg += "Maximum individuals per population is chosen,"
                            + " but not entered.";
                else
                    errMsg += "Invalid entry for maximum individuals per population.";
            }
        }
        if (jCheckLoc.isSelected()) {
            if (jRadioButtonRange.isSelected()) {
                String range = jTextRange.getText().trim();
                String revised = finalRanges(range);
//                if (!goodRange(range)) {
                if (revised.indexOf('E') != -1) {
                    if (err > 0) errMsg += newline + "Error in Range of Loci.";
                    err++;
                    locErr = 1;

                } else {
                    if (revised.length() == 0) {
                        errMsg += "Range of loci is desired, but not entered.";
                        if (err > 0) errMsg += newline;
                        err++;
                        locErr = 1;
                    } else {
                        locToRun = numLocToRun(revised, numLoci, true);
                        if (locToRun == 0) {
                            errMsg += "Ranges of loci result in NO loci to run.";
                            if (err > 0) errMsg += newline;
                            err++;
                            locErr = 1;
                        }
                    }
                }
            } else {
                String locDel = jTextLocDel.getText().trim();
                String revised = revisedLocDel(locDel, false);
                if (revised.indexOf('E') != -1) {
                    if (err > 0) errMsg += newline;
                    errMsg += "Invalid entries for Omitted loci.";
                    err++;
                    locErr = 1;
                } else {
                    if (locDel.length() == 0) {
                        if (err > 0) errMsg += newline;
                        errMsg += "Omitted loci are desired, but not entered.";
                        err++;
                        locErr = 1;
                    } else {
                        locToRun = numLocToRun(revised, numLoci, false);
                        if (locToRun == 0) {
                            errMsg += "Omitting loci result in NO loci to run.";
                            if (err > 0) errMsg += newline;
                            err++;
                            locErr = 1;
                        }
                    }
                }
            }   // end of "if (jRadioButtonRange.isSelected()) ... else"

        }   // end of "if (jCheckLoc.isSelected())"
        if (err > 0) {
            errMsg += newline + newline +
                    "Click OK to continue without these options," + newline +
                    "Cancel to go back to correct.";
            int k = JOptionPane.showConfirmDialog(this,
                                errMsg, "Entry Errors",
                                JOptionPane.OK_CANCEL_OPTION);
            if (k == 0) {  // "Yes" is clicked, continue,
                if (tempErr == 1) {
                    jCheckTemp.setSelected(false);
                    jTextTemp.setEnabled(false);
                }
                if (popErr == 1) {
                    jCheckPop.setSelected(false);
                    jTextPop.setEnabled(false);
                }
                if (sampErr == 1) {
                    jCheckSamp.setSelected(false);
                    jTextSamp.setEnabled(false);
                }
                if (locErr == 1) {
                    jCheckLoc.setSelected(false);
                    jTextLocDel.setEnabled(false);
                    jTextRange.setEnabled(false);
                    locToRun = numLoci;
                }
                if (popBurr > 0) {
                    jCheckBurr.setSelected(false);
                    jTextBurr.setEnabled(false);
                    jTextBurrOut.setEnabled(false);
                    jTextBCrit.setEnabled(false);
                }
                if (popLoc > 0) {
                    jCheckLocOut.setSelected(false);
                    jTextLoc.setEnabled(false);
                    jTextLocOut.setEnabled(false);
                }
                setToolTipBurTxt();
                setToolTip(jTextLoc, tipOneRange);
            } else {
                return false;
            }
        }
        return true;
    }
// =========================================================================
    private String getArguments() {
// return a string of the form:
// " i:infoDirective#.txt o:optDirective#.txt"
// where each # should be replaced by a number.
        String argument = "";
        String path = currPath;
        if (!path.endsWith(File.separator)) path += File.separator;
// the "if" may be unnecessary (those were called before this method)
        if (hasInputOutput() && goodEntries()) {
            String infoNe[] = collectInfo(false);
            if (infoNe[0].length() == 0) return argument;
            infoFile = getInfoFile("infoDirective", infoNe);
            if (infoFile.length() > 0) {
                if (samePath)
                    argument = " i:" + infoFile;
                else    // infoFile may contain white space, so the whole
                    // string should be in quotes
                    argument = " \"i:" + path + infoFile + "\"";
                String option[] = collectOption();
                optFile = getInfoFile("optDirective", option);
                String argument2 = "";
                if (optFile.length() > 0) {
// The same thing as in infoFile applies to optFile:
                    if (samePath)
                        argument2 = " o:" + optFile;
                    else
                        argument2 = " \"o:" + path + optFile + "\"";
                } else {
//                    JFrame frame = new JFrame();
                    String msg = "An open file for writing fails:\n" +
                            "  * No additional output files,\n  * " +
                            "No limiting individuals per population or loci";
                    JOptionPane.showMessageDialog(this, msg);
                }
                argument += argument2;
            }
        }
        return argument;
    }
// =========================================================================
// NO LONGER USED
// This and checkInp are replaced by GetFirstLineAtFile
    private static String [] getLinesAtFile(String inpFile, int guide[]) {
// Parameters passed by value, so use array to change the value.
// The array guide should have 2 terms, guide[0] represents
// the number of lines attempted, guide[1] for error
// Return array of maximum guide[0] lines, each line upto maxChar characters
        int nLines = guide[0];
        String lines[] = new String[nLines];
        int effLines = 0;
        int err = 0;
        try {
            FileInputStream fstream = new FileInputStream(inpFile);
            DataInputStream in = new DataInputStream(fstream);
            BufferedReader br = new BufferedReader(new InputStreamReader(in));
// Read File line by line up to nLines
            for (int n=0; n<nLines; n++) {
                String line = br.readLine();
                if (line == null) break;
                int i;
                int len = line.length();
                for (i=0; i<len; i++){
                    char c = line.charAt(i);
                    int ascii = (int) c;
                    if ((ascii >= 32 && ascii <= 127) ||
                        Character.isWhitespace(c)) continue;
                    break;
                }
                if (i < len) {
                    err++;
                }
                if (line == null) break;
                effLines++;
                lines[n] = line;
            }
// Close the input stream
            in.close();
        } catch (Exception e) {//Catch exception if any
//            System.err.println("Error: " + e.getMessage());
        }
        guide[0] = effLines;
        guide[1] += err;
        return shrinkArray(lines, effLines);
    }
// =========================================================================
// NO LONGER USED
// This and getLinesAtFile are replaced by GetFirstLineAtFile
    private int checkInp(String inpFile, boolean showLine) {
        if (jComboBoxFile.getSelectedIndex() == -1) return 0;
        int guide[] = new int[2];
        guide[0] = 1; // number of lines attempted to show
        guide[1] = 0; // 0 if the file is a text file.
        String lines[] = getLinesAtFile(inpFile, guide);
        if (!showLine) return guide[1];
        jTextShow.setText("");
        for (int i=0; i<lines.length; i++) {
            int len = lines[i].length();
            lines[i] = lines[i].substring(0, len);
            // replace tab by blank to shrink the length shown
            lines[i] = lines[i].replace('\t', ' ');
            jTextShow.setText(jTextShow.getText() + lines[i]);
            if (i < lines.length-1)
                jTextShow.setText(jTextShow.getText() + newline);
        }
        return guide[1];
    }
// =========================================================================
// NOT USED
    private String[] addOne(String[] array, String add) {
        int size = array.length;
        String[] temp = new String[size+1];
        System.arraycopy(array, 0, temp, 0, size);
        temp[size] = add;
        return temp;
    }
// =========================================================================

    private static String getFirstLineAtFile(String inpFile) {
// Read first line in file inpFile. Return either:
// * an empty string,
// * a string with the first character is '0', this can be a valid input file
// * a string with the first character is '1', if this is definitely
// cannot be a valid file.
        String add = "0";
        String line = "";
        try {
            FileInputStream fstream = new FileInputStream(inpFile);
            DataInputStream in = new DataInputStream(fstream);
            BufferedReader br = new BufferedReader(new InputStreamReader(in));
            line = br.readLine();
            if (line == null) return "";
            int i;
            int len = line.length();
            for (i=0; i<len; i++){
                char c = line.charAt(i);
                int ascii = (int) c;
                if ((ascii >= 32 && ascii <= 127) ||
                        Character.isWhitespace(c)) continue;
                break;
            }
            if (i < len) {  // there is a strange character
                add = "1";
            }
// Close the input stream
            in.close();
        } catch (Exception e) {//Catch exception if any
//            System.err.println("Error: " + e.getMessage());
        }
        return add + line;
    }

// =========================================================================
    private boolean outputNameOK() {
        String msg = "";
        String mainOutFile = jTextOutFile.getText().trim();
        String misDatFile = jTextMisDat.getText();
        missDatTime = getTimeStamp(jTextOutFolder.getText(), misDatFile);
        outFileTime = getTimeStamp(jTextOutFolder.getText(), mainOutFile);
        String misDatFileU = misDatFile.toUpperCase();
        if (misDatFileU.equals(mainOutFile.toUpperCase())) {
            msg = "Output File name should not take the reserved name for\n" +
                    "Missing Data File. Choose another name for Output.\n";
            JOptionPane.showMessageDialog(this, msg,
                            "Output Name Error", JOptionPane.ERROR_MESSAGE);
            return false;
        }
        if (!jCheckAppend.isSelected()) {
            if (fileExisted(jTextOutFolder.getText(), mainOutFile))
                msg += "Main Output exists, can be appended.\n";
            if (jCheckXtraOut.isEnabled() && jCheckXtraOut.isSelected()) {
                String note = "";
                int existed = 0;
                String xOutFileLD = jTextFieldxLD.getText();
                if (jTextFieldxLD.isEnabled() &&
                    fileExisted(jTextOutFolder.getText(), xOutFileLD)) {
                    existed++;
                    note += "LD";
                }
                String xOutFileHet = jTextFieldxHet.getText();
                if (jTextFieldxHet.isEnabled() &&
                    fileExisted(jTextOutFolder.getText(), xOutFileHet)) {
                    if (existed > 0) note +=", ";
                    existed++;
                    note += "Het-Excess";
                }
                String xOutFileCoan = jTextFieldxCoan.getText();
                if (jTextFieldxCoan.isEnabled() &&
                    fileExisted(jTextOutFolder.getText(), xOutFileCoan)) {
                    if (existed > 0) note +=", ";
                    existed++;
                    note += "Coancestry";
                }
                String xOutFileTemp = jTextFieldxTemp.getText();
                if (jTextFieldxTemp.isEnabled() &&
                    fileExisted(jTextOutFolder.getText(), xOutFileTemp)) {
                    if (existed > 0) note +=", ";
                    existed++;
                    note += "Temporal";
                }
                if (existed > 0) {
                    msg += "(Tabular-format) Output File";
                    if (existed > 1) msg += "s";
                    msg += " for " + note + " exist";
                    if (existed == 1) msg += "s";
                    msg += ("," + newline + "can be appended." + newline);
//                msg += ", will not be appended.\n";
                }
            }
        }
        if (jCheckBurr.isEnabled() && jCheckBurr.isSelected()) {
            String burrFile = jTextBurrOut.getText();
            if ((burrFile.toUpperCase()).equals(mainOutFile.toUpperCase())) {
                msg = "Output File cannot have the same name as\n" +
                        "Burrow Coefficicients File.\n";
                JOptionPane.showMessageDialog(this, msg,
                            "Output Name Error", JOptionPane.ERROR_MESSAGE);
                return false;
            }
            if (fileExisted(jTextOutFolder.getText(), burrFile)) {
                msg += "Burrow Coefficients File exists, will not be appended.\n";
            }
        }
        if (jCheckLocOut.isSelected()) {
            String locFile = jTextLocOut.getText();
            if ((locFile.toUpperCase()).equals(mainOutFile.toUpperCase())) {
                msg = "Output File cannot have the same name as\n" +
                        "Frequency Data File.\n";
                JOptionPane.showMessageDialog(this, msg,
                            "Output Name Error", JOptionPane.ERROR_MESSAGE);
                return false;
            }
            if (fileExisted(jTextOutFolder.getText(), locFile)) {
                msg += "Frequency Data File exists, will not be appended.\n";
            }
        }
        if (msg.length() > 0) {
            msg += "\nClick OK to continue, existing files will be overwritten.";
            int k = JOptionPane.showConfirmDialog(this, msg,
                    "Output File(s) existed", JOptionPane.OK_CANCEL_OPTION);
            return (k == 0);
        } else return true;
    }
// =========================================================================
    private static int getGenLoci(String path, String fileName)
    {
    // get number of loci in a GENEPOP file.
    // (for convenience, get numPop value as well)
    // This is a short version of getGenData, to give a quick scan
    // to see if this is a wrong format
        if (fileName.length() == 0) return 0;
        String fullName = path + fileName;
        numPop = 0;
        try {
            FileInputStream fstream = new FileInputStream(fullName);
            DataInputStream in = new DataInputStream(fstream);
            BufferedReader br = new BufferedReader(new InputStreamReader(in));
            String line;
            // the first line in GENEPOP format is ignored:
            if (br.readLine() == null) return 0;
    // Read lines until reaching "pop"
            int nLoci = 0;
            boolean getPop = false;
            while ((line = br.readLine()) != null) {
                String pop = line.trim().toUpperCase();
                if (pop.equals("POP")) {
                    getPop = true;
                    break;
                }
                nLoci += getNumTokens(line);
            }
            // continue to the end of file to count number of populations
            int p = 0;
            if (getPop) {
                p = 1;
                while ((line = br.readLine()) != null) {
                    String pop = line.trim().toUpperCase();
                    if (pop.equals("POP")) p++;
                }
            }
            numPop = p;
            popToRun = numPop;
            in.close();
            // if there is no "pop", this is not a GENEPOP file
            if (getPop) return nLoci;
            else return 0;   // EOF attained
            // now each line is assumed for 1 individual:
        } catch (Exception e){//Catch exception if any
            System.err.println("Error: " + e.getMessage());
            return 0;
        }
    }

// =========================================================================

    private static String[] getGenData(String path, String fileName) {
    // get number of loci and individuals per pop in a GENEPOP file
        String dataStr[] = new String[2];
        dataStr[0] = ""; // to store number of loci
        dataStr[1] = ""; // to store number of individuals per pop, for all pops
        if (fileName.length() == 0) return dataStr;
        String fullName = path + fileName;
        try {
            FileInputStream fstream = new FileInputStream(fullName);
            DataInputStream in = new DataInputStream(fstream);
            BufferedReader br = new BufferedReader(new InputStreamReader(in));
            String line;
            // the first line in GENEPOP format is ignored:
            if (br.readLine() == null) return dataStr;
    // Read lines until reaching "pop"
            int nLoci = 0;
            int p = 0;
            boolean getPop = false;
            while ((line = br.readLine()) != null) {
                p++;
                String pop = line.trim().toUpperCase();
                if (pop.equals("POP")) {
                    getPop = true;
                    break;
                }
                nLoci += getNumTokens(line);
            }
            // if there is no "pop", this is not a GENEPOP file
            if (getPop) dataStr[0] += nLoci;
            else return dataStr;   // EOF attained
            // now each line is assumed for 1 individual:
            int nSamp = 0;
            while ((line = br.readLine()) != null) {
                String pop = line.trim().toUpperCase();
                if (pop.length() > 0) nSamp++;
                if (pop.equals("POP")) {
                    nSamp--;
                    dataStr[1] += nSamp + " ";
                    nSamp = 0;
                }
            }
            dataStr[1] += nSamp + " ";
            in.close();
        } catch (Exception e){//Catch exception if any
            System.err.println("Error: " + e.getMessage());
        }
        return dataStr;
    }
// =========================================================================

    private static String[] showDataInfo(String path, String fileName,
                                        boolean gen)
    {
        String dataStr[] = new String[2];
        dataStr[0] = "";
        dataStr[1] = "";
        if (gen) {
            dataStr = getGenData(path, fileName);
        } else {
            dataStr = getFstatData(path, fileName);
        }
        numLoci = 0; numPop = 0;
        if (dataStr[0].equals("")) return dataStr;
        int data[] = getSequence(dataStr[1]);
        // the first item data[0] is the number of elements
        int n = data.length;
        numLoci = getPositiveInt(dataStr[0]);
        numPop = data[0];
        popToRun = numPop;
        int dataLess[] = new int[n-1];
        System.arraycopy(data, 1, dataLess, 0, n-1);
        String info[] = new String[3];
        int extremum[] = getExtremum(dataLess);
        info[0] = "Number of loci = " + dataStr[0] +
                "\nNumber of populations = " + data[0];
        if (n == 2) { // only one population
            info[1] = "Number of individuals = " + extremum[0];
            info[2] = "";
        } else if (extremum[0] == extremum[1]) {
            info[1] = "Number of individuals per population = " + extremum[0];
            info[2] = "";
        } else if (n == 3) {
            info[1] = "Larger population, # individuals = " + extremum[0];
            info[2] = "Population ";
            if (data[1] < data[2]) info[2] += "1";
            else info[2] += "2";
            info[2] += ", # individuals = " + extremum[1];
        } else {
            info[1] = "Largest population  = " + extremum[0];
            info[2] = "Smallest population = " + extremum[1];
        }
        return info;
    }
// =========================================================================

    private static int getFstatLoci(String path, String fileName) {
    // get number of loci in a FSTAT file, return 0 if data are invalid.
    // In FSTAT file, the first line contains #loci, #pop, length of allele.
    // If any of them is 0 or less, it is an error.
    // This is a shorter version of getFstatData.
        if (fileName.length() == 0) return 0;
        String fullName = path + fileName;
        try {
            FileInputStream fstream = new FileInputStream(fullName);
            DataInputStream in = new DataInputStream(fstream);
            BufferedReader br = new BufferedReader(new InputStreamReader(in));
            String line;
            // the first line in GENEPOP format is ignored:
            if ((line = br.readLine()) == null) return 0;
            // for FSTAT format, the first line contains #pop, #loci, etc.
            line = line.replace(',', ' ');  // commas are ignored
            // this nPop not used, put here just in case we want to compare
            // with variable pop, which counts the number of pops read
            numPop = getPositiveInt(line, 0);
            popToRun = numPop;
            int nLoci = getPositiveInt(line, 1);
            in.close();
            if (nLoci <= 0 || numPop <= 0 || getPositiveInt(line, 2) <= 0
                    || getPositiveInt(line, 3) <= 0) return 0;
            else return nLoci;
        } catch (Exception e){//Catch exception if any
            System.err.println("Error: " + e.getMessage());
            return 0;
        }
    }

// =========================================================================

    private static String checkFormat(String path, String fileName, boolean gen)
    // return a string, the first character is a number,
    // 0: good, 1: the other format is OK, 2: both are not fit.
    {
        int nLoci;
        int result;
        String msg = "";
        if (gen) nLoci = getGenLoci(path, fileName);
        else nLoci = getFstatLoci(path, fileName);
        if (nLoci == 0) { // check other format
            int n;
            if (gen) {
                n = getFstatLoci(path, fileName);
                if (n == 0) {
                    msg = "File " + fileName +
                            " does not seem to be a valid input file " +
                            newline + "of any format. Continue regardless? ";
                    result = 2;
                } else {
                    msg = "File " + fileName + " seems to be in FSTAT format."
                            + newline + "Continue by changing format? ";
                    result = 1;
                }
            } else {
                n = getGenLoci(path, fileName);
                if (n == 0) {
                    msg = "File " + fileName +
                            " does not seem to be a valid input file."
                            + newline + "Continue regardless? ";
                    result = 2;
                } else {
                    msg = "File " + fileName + " seems to be in GENEPOP format."
                            + newline + "Continue by changing format? ";
                    result = 1;
                }
            }
            nLoci = n;
        } else result = 0;
        numLoci = nLoci;
        return (result + msg);
    }

// =========================================================================


    private static String[] getFstatData(String path, String fileName) {
    // get nmumber of loci and individuals per pop in a FSTAT file
        String dataStr[] = new String[2];
        dataStr[0] = ""; // to store number of loci
        dataStr[1] = ""; // to store number of individuals per pop, for all pops
        if (fileName.length() == 0) return dataStr;
        String fullName = path + fileName;
        try {
            FileInputStream fstream = new FileInputStream(fullName);
            DataInputStream in = new DataInputStream(fstream);
            BufferedReader br = new BufferedReader(new InputStreamReader(in));
            String line;
            // the first line in GENEPOP format is ignored:
            if ((line = br.readLine()) == null) return dataStr;
            // for FSTAT format, the first line contains #pop, #loci, etc.
            line = line.replace(',', ' ');  // commas are ignored
            // this nPop not used, put here just in case we want to compare
            // with variable pop, which counts the number of pops read
            int nPop = getPositiveInt(line, 0);
            int nLoci = getPositiveInt(line, 1);
            if (nLoci <= 0 || nPop <= 0 || getPositiveInt(line, 2) <= 0
                    || getPositiveInt(line, 3) <= 0) return dataStr;
    // Read all loci, commas ignored:
            int p = 0;
            boolean getPop = false;
            while ((line = br.readLine()) != null) {
                line = line.trim();
                p += getNumTokens(line);
                if (p >= nLoci) {
                    getPop = true;
                    break;
                }
            }
            if (!getPop) return dataStr;
            if ((line = br.readLine()) == null) return dataStr;
            // the next while loop is for allowing empty lines
            // before lines for genotypes
            line = line.trim();
            while (line.length() == 0) {
                line = br.readLine();
                if (line == null) {
                    getPop = false;
                    break;
                }
                line = line.trim();
            }
            if (!getPop) return dataStr; // only empty lines after loci
            dataStr[0] += nLoci;
            String popID = getFirstToken(line);
            // now each nonempty line is assumed for 1 individual
            int pop = 1;
            int nSamp = 1;
            while ((line = br.readLine()) != null) {
                line = line.trim();
                if (line.length() == 0) continue;
                String newID = getFirstToken(line);
                if (newID.equals(popID)) {
                    nSamp++;
                } else {
                    pop++;
                    dataStr[1] += nSamp + " ";
                    popID = newID;
                    nSamp = 1;
                }
            }
            // the last pop:
            dataStr[1] += nSamp + " ";
            in.close();
        } catch (Exception e){//Catch exception if any
            System.err.println("Error: " + e.getMessage());
        }
        return dataStr;
    }
// =========================================================================

    private boolean isGoodToGo(String fileName, boolean gen, boolean checkOnly)
    {
    // This involves checking information of the input file.
    // When this method is called only for checking, set checkOnly = true.
    // When this method is called before executing Ne, set it false.
        if (fileName.trim().length() == 0) return false;
        String path = jTextInpFolder.getText().trim();
        if (currPath.equals(path) && samePath) path = "";
        else path += File.separatorChar;
        String line1 = getFirstLineAtFile(path+fileName);
//        if (checkInp(path+fileName, false) != 0) {
//            String msg = "Input is not a text file.";
        if (line1.length() > 0 && line1.charAt(0) == '1') {
            String msg = "Input is not valid, likely not a text file.";
//            JFrame frame = new JFrame();
            JOptionPane.showMessageDialog(this, msg, "Data Input Error",
                                JOptionPane.ERROR_MESSAGE);
            return false;
        }
        numLoci = 0;    // numLoci and numPop will be evaluated at showDataInfo
        String info[] = showDataInfo(path, fileName, gen);
        int n = info.length;
        String msg = "";
        if (info[0].length() == 0) {
            msg += "The input file may not be in the chosen format";
//            JFrame frame = new JFrame();
            if (checkOnly) {
                JOptionPane.showMessageDialog(this, msg, fileName,
                                JOptionPane.WARNING_MESSAGE);
                return false;
            } else {
                msg += newline +
                        "Continue? (Ne may not run with this input file)" +
                        newline + "Click Cancel to quit";
                int k = JOptionPane.showConfirmDialog(this,
                        msg, "Possible Data Input Error",
                        JOptionPane.OK_CANCEL_OPTION, JOptionPane.ERROR_MESSAGE);
                if (k != 0) return false;
            }
        }
        int warnRatio = 0;
        int k = getNumTokens(info[1]);
        int nSamp = getPositiveInt(info[1], k-1);
        boolean reducedSamp = false;
        String warnMethod = "";
        if (jCheckLD.isSelected() || jCheckCoan.isSelected()) {
        // The first string info[0] should contain number of loci
        // at token 5, number of populations at token 10.
        // The last token of info[1] contains the maximum individuals.
        // (Refer to method showDataInfo where info[0], info[1] are assigned.)
            if (jCheckSamp.isSelected()) {
                k = getPositiveInt(jTextSamp.getText().trim());
                if (k > 0 && k < nSamp) {
                    nSamp = k;
                    reducedSamp = true;
                }
            }
        // estimate relative time to run LD and Coancestry.
        // For both, it is rougly proportional to the square of number of loci.
        // For Coancestry, also proportional to square of sample size.
            float locRatio = (float) locToRun / stdLoc;
            float smpRatio = (float)nSamp / stdSamp;
            float ratio = locRatio*locRatio*smpRatio;
            float ratioLD = 0.0F;
            if (jCheckLD.isSelected()) {
                ratioLD = ratio*(listPcrit.getItemCount()+1);
                warnMethod += "LD";
            }
            float ratioCn = 0.0F;
            if (jCheckCoan.isSelected()) {
                ratioCn = ratio*locRatio*smpRatio;
                if (warnMethod.length() > 0)    // LD also is run
                    warnMethod += " and Coancestry methods";
                else warnMethod += "Coancestry method";
            } else warnMethod += " method"; // only LD is run
            float totRatio = (ratioLD + ratioCn) * popToRun;
//            if (smpRatio == 0) smpRatio = 1;
//            if (jCheckCoan.isSelected()) smpRatio *= smpRatio;
//            float totRatio = locRatio * smpRatio * numPop;
//            if (jCheckCoan.isSelected()) totRatio *= Math.sqrt(totRatio);
            warnRatio = (int) (totRatio / stdRatio);
            if (warnRatio > 100) warnRatio = 100;
        }
        for (int i = 0; i < n; i++) {
            msg += info[i] + newline;
        }
        if ((warnRatio >= 0.6) && (!checkOnly)) {
            msg += "This very large input file whose data are listed above" +
                    newline + "[with " + locToRun + " loci, " + popToRun +
                    " population(s)";
            if (reducedSamp) msg += (", " + nSamp + " individuals per pop");
            msg += " to run]" + newline + "may take hours/days to finish with "
                    + warnMethod + "." + newline + "Warning level = " +
                    warnRatio + ". (Max = 100.)" + newline +
                    "Click OK to continue, Cancel to quit.";
            JFrame frame = new JFrame();
            k = JOptionPane.showConfirmDialog(frame, msg,
                            "Large Data Input", JOptionPane.OK_CANCEL_OPTION);
            //, JOptionPane.WARNING_MESSAGE);
            if (k != 0) return false;
        } else if (checkOnly) {
//            JFrame frame = new JFrame();
            JOptionPane.showMessageDialog(this, msg, "Info On Data Input",
                                JOptionPane.INFORMATION_MESSAGE);
        }
        if (checkOnly) return true;
        else {
            if (acceptBurrSize(numLoci, numPop, maxPopBur))
                return outputNameOK();
            else return false;
        }
    }
// =========================================================================
    private String xterMac() {
        String xterm = "/usr/X11/bin/xterm";
        if (fileExisted(xterm)) return xterm;
        else {
            xterm = "/usr/share/terminfo/78/xterm";
            if (fileExisted(xterm)) return xterm;
        }
        return "";
    }
// =========================================================================
    private void getCmdHeader() {
        String cmd;
        String option;
        String prefix;
        if (osName.equals("Windows")) {
            cmd = "cmd";
            option = "/c";
            if (samePath) {
                prefix = "start " + exeName;
                strCmd = new String[]{cmd, option, prefix};
            } else {
// since currPath may contain white spaces, the command line to execute
// Ne2 should be enclosed in double quotes.
                int n = currPath.length();
                boolean hasBlank = false;
                for (int k = 0; k < n; k++) {
                    if (Character.isWhitespace(currPath.charAt(k))) {
                        hasBlank = true;
                        break;
                    }
                }
                if (hasBlank) {
                    String msg = "If run from command line, " +
                            "should start in directory:" + newline + currPath;
//                    JOptionPane.showMessageDialog(this, msg);
                    prefix = "\"" + currPath + File.separator + exeName + "\"";
                    strCmd = new String[]{prefix};
                } else {
            // this only work if currPath has no white space
                    prefix = "start " + currPath + File.separator + exeName;
                    strCmd = new String[]{cmd, option, prefix};
                }
            }
        } else {    // for non-Windows system
            if (samePath)
                prefix = "./" + exeName;
            else
                prefix = "\"" + currPath + File.separator + "./" + exeName + "\"";
//            else prefix = currPath + File.separator + "./";
// Having two slashes in front of the asterisk on the line after these
// comments will uncomment the assignments of variables: cmd, option.
// The rest of this "else" statement are then commented out, so these
// variables cmd, option won't be conditioned for non-Windows systems
// Having one slash will do the reverse.
/*  // This is the line mentioned above.
//            cmd = "sh"; // there is no difference if cmd ="sh" or "bash"
            cmd = "bash";
            option = "-c";
/*/
            if (osName.equals("Mac")) {
//                String xterm = "/usr/X11/bin/xterm";
//                if (!fileExisted(xterm)) {
                String xterm = xterMac();
                if (xterm.length() == 0) {
                    String msg = "Terminal 'xterm' is not found under known "
                        + "paths in your system!"
                        + newline + "Ne will run in the background," + newline
                        + "unless this Interface was launched from command line."
                        + newline +
                        "(No easy way to interrupt Ne if it runs in the background.)";
                    JOptionPane.showMessageDialog(this, msg);
                    cmd = "sh";
                    option = "-c";
                } else {
                    cmd = xterm;
                    option = "-e";
                }

            } else {    // not Mac, it is likely OK to use xterm without path
                if (osName.equals("Linux")) cmd = "xterm";
                else cmd = "xterm"; // change if "xterm" not OK for non-Linux
                option = "-e";
                try {   // is it is really OK? Otherwise, will run in background
                    Runtime.getRuntime().exec(new String[]{cmd, option, "exit"});
                } catch(Exception e) {
                    String msg = "'xterm' is either not in your system " +
                            "or not in path environment."
                        + newline + "Ne will run in the background," + newline
                        + "unless this Interface was launched from command line."
                        + newline +
                        "(No easy way to interrupt Ne if it runs in the background.)";
                    JOptionPane.showMessageDialog(this, msg);
                    cmd = "sh";
                    option = "-c";
                }
            }
//*/
            strCmd = new String[]{cmd, option, prefix};
        }
        cmdMaxInd = strCmd.length - 1;
    }

// =========================================================================

    private int runNe(String argument) {
// issue command line here, after getting arguments for C-program
        if (argument.length() == 0) return 1;
        String[] cmdSeq = new String[cmdMaxInd+1];
        System.arraycopy(strCmd, 0, cmdSeq, 0, cmdMaxInd);
// same as:
//        for (int i = 0; i < cmdMaxInd; i++) cmdSeq[i] = strCmd[i];
        String cmdLine = strCmd[cmdMaxInd] + argument + " rm";
        cmdSeq[cmdMaxInd] = cmdLine;
//JFrame frame0 = new JFrame();
//JOptionPane.showMessageDialog(frame0, cmdSeq);
        String instruct = "To run command line,";
        instruct += " open a terminal at directory:" + newline;
        instruct += currPath + newline;
        instruct += "and issue the following command:" + newline;
        if (!osName.equals("Windows")) instruct += "./";
        instruct +=  exeName + " i:" + infoFile;
        if (optFile.length() > 0) instruct += " o:" + optFile;
        String infoFull = infoFile;
        String optFull = optFile;
        if (!samePath) {
            String path = currPath;
            if (!path.endsWith(File.separator)) path += File.separator;
            infoFull = path + infoFile;
            optFull = path + optFile;
        }
        try {
            Process pr;
            String msg = "";
//            msg = "On " + osName + ", Command line:" + newline;
// Strange: if array cmdSeq has size 1 (i.e. cmdMaxInd = 0), then
// "Exception = null" is thrown; so execute one single string instead
            if (cmdMaxInd > 0) {
                pr = Runtime.getRuntime().exec(cmdSeq);
//                for (int i=0; i<= cmdMaxInd; i++) msg += (cmdSeq[i] + " ");
//                msg += newline;
            } else { // this may happen only when jar file is launched from DOS
                pr = Runtime.getRuntime().exec(cmdLine);
            }
//*
//----------------------------------------------------------------------
// Uncomment one of the two lines to put condition to run the block
// of code below.
//            if (!osName.equals("Windows") && !osName.equals("Linux"))
//            if (!osName.equals("Windows"))
//----------------------------------------------------------------------
// The block of code here is to hang the program until the executable
// program, from the command, finishes running. This "hang around" is
// realized by keeping readLine() (method waitFor does not do that).
// However, without these lines of code here, the program in IDE
// environment still in "run" mode, even when the interface is closed!
// (by clicking "Exit")
            {
                BufferedReader in = new BufferedReader
                    (new InputStreamReader(pr.getInputStream()));
                String line;
                while ((line = in.readLine()) != null) {
// "line" is the line printed to the shell by the program cited in
// the command. The following code never happens when a separate shell
// is launched; probably because "line" is already printed there
                    System.out.println(line);
                }
                in.close();
                int exitVal = pr.waitFor();
//                String msg = "";
                String outFolder = jTextOutFolder.getText();
                String outputFile = jTextOutFile.getText().trim();
                if (getTimeStamp(outFolder, outputFile) > outFileTime) {
//                if (!fileExisted(infoFull) && !fileExisted(optFull)) {
//                if (exitVal == 0) {
                    msg += "Ne is finished running.";
                    msg += (" Outputs are written to:" + newline + outputFile);
//                    msg += (" Exit value = " + exitVal);
                    String misDatFile = jTextMisDat.getText();
                    if (getTimeStamp(outFolder, misDatFile) > missDatTime) {
                        msg += newline + "There are missing data in input file";
                        jTextMisDat.setEnabled(true);
                    } else jTextMisDat.setEnabled(false);
                } else {
                    msg += "Ne may not run.";
                    if (fileExisted(infoFull) && fileExisted(optFull)) {
                        msg += (" Exit value = " + exitVal);
                        if (!osName.equals("Windows"))
                        msg += newline + "Check if '" + exeName + "' is executable.";
                        msg += newline + instruct;
                    } else {
                        msg += " Check input file.";
                    }
                }
//                JFrame frame = new JFrame();
//                JOptionPane.showMessageDialog(frame, msg);
                JOptionPane.showMessageDialog(this, msg);
            }
//----------------------------------------------------------------------
//*/
            return 0;
// if use waitFor, then may add InterruptedException
//        } catch(IOException | InterruptedException e) {
        } catch(Exception e) {
//            System.out.println(e.getMessage());
            String msg = e.getMessage() + newline + instruct;
//            JFrame frame = new JFrame();
//            JOptionPane.showMessageDialog(frame, "Exception: " + msg);
            JOptionPane.showMessageDialog(this, "Exception: " + msg);
            return 1;
        }
    }
// =========================================================================

    private void exeNeRun() {
        if (!hasExe(exeName)) return;
        if (!hasInputOutput()) return;
        if (!goodEntries()) return;
        String fileName = getFile(jComboBoxFile);
        boolean ready = isGoodToGo(fileName, jRadioButtonGen.isSelected(), false);
        if (ready) {
            String argument = getArguments();
            runNe(argument);
        }
    }
// =========================================================================
    private void getOSName() {
        String os = System.getProperty("os.name").toLowerCase();
        if (os.indexOf("win") >= 0) {
            osName = "Windows";
  //          exeName = "Ne2";
        } else if (os.indexOf("mac") >= 0) {
            osName = "Mac";
            exeName += "M";
  //          exeName = "Ne2M";
        } else if (os.indexOf("nux") >= 0) {
            osName = "Linux";
            exeName += "L";
  //          exeName = "Ne2L";
        } else if (os.indexOf("nix") >= 0) {
            osName = "Unix";
            exeName += "U";
  //          exeName = "Ne2U";
        } else {
//            JFrame frame = new JFrame();
//            JOptionPane.showMessageDialog(frame,
            JOptionPane.showMessageDialog(this,
                "This program may not work in your system!");
            osName = os;
            exeName += "E";
  //          exeName = "Ne2E";
        }
    }

// =========================================================================
    private static boolean hasExe (String exeFile) {
// check to see if exeFile is in current directory
// For Windows, the exeFile should have extension "exe".
        if (osName.equals("Windows")) exeFile += ".exe";
        String fullName;
        if (samePath) fullName = exeFile;
//        else fullName = currPath + File.separator + exeFile;
        else {
            fullName = currPath;
            if (!fullName.endsWith(File.separator)) fullName += File.separator;
            fullName += exeFile;
        }
        File f = new File (fullName);
        if (f.exists()) {
//            boolean exeOK = (f.canRead() && f.canExecute());
            boolean exeOK = (f.canExecute());
            if (!exeOK) {
                f.setExecutable(true);
            }
/* The following code was previously implemented, using command line
// to give permission to execute. The command line may not always work
// as stated in the comments below.
// Now, we use a simple method available in File: setExecutable().
// If this has problem because of JDK version, revert to the old one.
// ------------------------------------------------------------------
            if ((!exeOK) && (!osName.equals("Windows"))) {
// mode 755 consist of 7, 5, 5. The first one (7) is for the user.
// The second and third digits are for referring to group, then others.
// 7 = (in binary) 111 = 100 + 010 + 001 = read + write + execute
// 5 = read + execute (no writing privilege)
// so no other users can overwrite or delete this executable file.
// This command is necessary since Ne2 downloaded from the Internet
// may loose its permission to execute in Linux or Unix machine.
// If fullName includes the path and if the path has white spaces,
// then the command line cmd below does not work (no Exception thrown however).
// (If fullName is surrounded by double quotes, i.e.,
//              String cmd = "chmod 755 \"" + fullName + "\"";
// then it always fails whether or not path has white spaces!)
//
// When making Ne2 excecutable fails, Ne2 is still not executable,
// a message will be popped up asking the user to manually type the command
                String cmd = "chmod 755 " + fullName;
                try {
                    Runtime.getRuntime().exec(cmd);
                } catch (Exception e){
//
//                    JFrame frame = new JFrame();
//                    JOptionPane.showMessageDialog(frame,
//                                        "Exception: "+e.getMessage());
//
//
                }
                // check if file now can be executed:
                f = new File (fullName);
                exeOK = (f.canExecute());
            }
//*/
            // Check to make sure:
            exeOK = (f.canExecute());
            if (!exeOK) {
                String msg = "File \"" + fullName + "\"" + newline +
                        "does not have permission to execute.";
                if (!osName.equals("Windows")) msg += newline +
                        "Suggestion: Open a terminal, change directory to" +
                        newline + currPath + newline +
                        "then type the command line:" + newline +
                        "chmod 755 " + exeName;
                JFrame frame = new JFrame();
                JOptionPane.showMessageDialog(frame, msg);
                return false;
            } else return true;
        } else {
            JFrame frame = new JFrame();
            JOptionPane.showMessageDialog(frame, "The executable \"" +
                exeFile + "\" should be in directory" + newline + currPath);
            return false;
        }
    }
// =========================================================================
    private String getPath() {
        String runPath = currDirectory();
        String name = this.getClass().getName().replace('.', '/');
        String classJar = this.getClass().getResource("/" + name + ".class").toString();
        // first try to see if this is run from "jar" file:
        try {
// remove junk to reveal the core pathname of the jar file.
        // The string test is used to see what's going on - comment out later
            String test = name + newline + classJar + newline;
            name = classJar.substring(0, classJar.indexOf(".jar"));
            test += name + newline;
//            name = name.substring(name.lastIndexOf(':')-1,
// use +1 to get rid of the "disk" letter, which probably not acceptable
// in Linux or Mac as a directory.
            name = name.substring(name.lastIndexOf(':')+1,
                    name.lastIndexOf('/')+1).replace('%', ' ');
            test += name + newline;
    // remove escape characters
            String s = "";
            int k;
            for (k=0; k<name.length(); k++) {
                s += name.charAt(k);
                if (name.charAt(k) == ' ') k += 2;
            }
            test += newline + "s = " + s + newline;
// eliminate the last '/':
            k = s.length()-1;
            if (s.charAt(k) == '/') s = s.substring(0, k);
// replace '/' with system separator char
            name = s.replace('/', File.separatorChar);

            test += "Final name = " + name;
/*
            JFrame frame = new JFrame();
            JOptionPane.showMessageDialog(frame, test);
//*/
        } catch (Exception e) {
// this means it is not run as a jar file (samePath is still true)
            return runPath;
        }

// For Mac or Linux, probably "runPath" and "name" will be the same
// when the jar file is called from command in the folder of jar file.
// For Windows, "runPath" contains the disk letter, and "name" was removed
// (see comments in previous "try" statement).
// Need to see if the directory containing jar file, which is "name",
// and the current directory (where the command is issued to run this jar
// file), which is "runPath", are the same, we use the same language:
// "CanonicalPath", before comparing
// Also, in Windows, it is better to include the disk letter, so "path"
// variable below is to restore the disk letter for "name".
        File directory = new File (name);
        String path;
        try {
            path = directory.getCanonicalPath();
        } catch(Exception e) {
//            JFrame frame = new JFrame();
//            JOptionPane.showMessageDialog(frame, "Cannot locate path."
            JOptionPane.showMessageDialog(this, "Cannot locate path."
                    + newline + "Exception = " + e.getMessage());
            samePath = false;
            return runPath;
        }
        samePath = (path.equals(runPath));
// The rest (except the return statement) for checking only (comment out later)
/* (One slash at the beginning of this line is to comment out, two to keep)
        String msg = "name = " + name + newline +
                "Return value of getPath = " + path + newline +
                "Current directory = " + runPath + newline +
                "Value of samePath = ";
        if (samePath) msg += "true";
        else msg += "false";
        JFrame frame = new JFrame();
        JOptionPane.showMessageDialog(frame, msg);
//*/
        return path;
    }
// =========================================================================

    private static long getTimeStamp (String path, String fileName) {
        String fullName;
        if (path.length() == 0) fullName = fileName;
        else fullName = path + File.separator + fileName;
        File file = new File (fullName);
        // lastModified is the date in milliseconds
        if (file.exists()) return file.lastModified();
        else return 0;
    }
// =========================================================================
//
// add in October 2012:

    private boolean hasOption() {
        if (jCheckXtraOut.isSelected()) return true;
        if (jCheckSamp.isSelected()) return true;
        if (jCheckLocOut.isSelected()) return true;
        if (jCheckBurr.isSelected()) return true;
//        if (hasCI == 0 || randLD > 0) return true;
        if (hasCI == 0) return true;
        if (jCheckPop.isSelected()) return true;
        if (jCheckLoc.isSelected()) return true;
        return false;
    }
// =========================================================================

    private String getCmdLine(String infoName, String optName) {
// return a string of the form:
// " i:" + infoName + " o:" + optName
// where each # should be replaced by a number.
        String argument = "";
        String path = currPath;
        if (!path.endsWith(File.separator)) path += File.separator;
        if (hasInputOutput() && goodEntries()) {
            String infoNe[] = collectInfo(true);
            int lineNumber = infoNe.length;
            if (infoNe[0].length() == 0) return argument;
            String fullName;
            if (samePath)
                fullName = infoName;
            else
                fullName = path + infoName;
//            File info = new File (fullName);
            try {
                FileWriter fstream = new FileWriter(fullName);
                BufferedWriter out = new BufferedWriter(fstream);
                for (int j=0; j < lineNumber; j++) {
                    if (infoNe[j] == null) break;
                    out.write (infoNe[j]);
                    out.newLine();
                }
                out.close();
                argument += " i:" + infoName;
            } catch (IOException e) {
                return argument;
            }
            String option[] = collectOption();
            if (!hasOpt) return argument;	// no need for option file
            lineNumber = option.length;
            if (samePath)
                fullName = optName;
            else
                fullName = path + optName;
//            File info = new File (fullName);
            try {
                FileWriter fstream = new FileWriter(fullName);
                BufferedWriter out = new BufferedWriter(fstream);
                for (int j=0; j < lineNumber; j++) {
                    if (option[j] == null) break;
                    out.write (option[j]);
                    out.newLine();
                }
                out.close();
                argument += " o:" + optName;
            } catch (IOException e) {
//                JFrame frame = new JFrame();
                String msg = "An open file for writing fails:\n" +
                            "  * No additional output files,\n  * " +
                            "No limiting individuals per population or loci";
//                JOptionPane.showMessageDialog(frame, msg);
                JOptionPane.showMessageDialog(this, msg);
                hasOpt = false;
                return argument;
            }

        }	// end of if (hasInputOutput() && goodEntries())
        return argument;
    }


// =========================================================================
    private boolean confirmParam(String infoName, String optName) {
// return true if creating parameter files is confirmed, false if cancel
        String msg = "Click OK to create parameter file";
        if (hasOpt) msg += "s";
        msg += " (name";
        if (hasOpt) msg += "s";
        msg += " in squared brackets):" + newline + "          [" +
                infoName + "]";
        if (hasOpt) msg += "    and    " + "[" + optName + "]";
        msg += newline + "to reside in directory (in quotes):" + newline +
                 "\"" + currPath + "\"";
        int n = 0;
        // n = 0 if info file and/or opt file will be newly created,
        // n = 1 if only info File is to be overwritten, 2 if both.
        String filestr = "";
        if (fileExisted(currPath, infoName)) {
            n++;
            filestr += " [" + infoName + "]";
        }
        if (hasOpt && fileExisted(currPath, optName)) {
            n++;
            if (n > 1) filestr += ",";
            filestr += " [" + optName + "]";
        }
        if (n > 0) {
            msg += newline + "Existing file";
            if (n > 1) msg += "s";
            msg +=  filestr + " will be overwritten. " + newline +
                    "Click Cancel to abort.";
        } else return true; // no need to issue overwrite warning
        int k = JOptionPane.showConfirmDialog(jPanelOutput,
                                msg, "Create Parameter Files",
                                JOptionPane.OK_CANCEL_OPTION);
        if (k == 0) return true;
        else return false;
    }

// =========================================================================
    private void createParam(String infoName, String optName) {
        String cmdLine = getCmdLine(infoName, optName);
        if (cmdLine.length() == 0) {
            JOptionPane.showMessageDialog(jPanelOutput,
                    "Error: No parameter files are created!");
            return;
        }
        String instruct = "Parameter file";
        if (hasOpt) instruct += "s were";
        else instruct += " was";
        instruct += " created [enclosed by squared brackets]:" + newline +
                    "          [" + infoName + "]";
        if (hasOpt) instruct += "    and    " + "[" + optName + "]";
        instruct += "       in directory:" + newline + currPath + newline +
                    "To run command line, open a terminal at the directory " +
                    " containing" + newline + "the executable " +
                    exeName + " and the parameter file";
        if (hasOpt) instruct += "s";
        instruct += " (available at '" + jMenuAction.getText().trim() +
                    "' menu)," + newline + "then issue the command:" +
                    newline + "       ";
        if (!osName.equals("Windows")) instruct += "./";
        instruct += exeName + cmdLine + newline;
        if (hasOpt) instruct += "(Parameter files: " + infoName + ", " + optName
                    + " are preceded by either letter i or o, and a colon.)";
        else instruct += "(Parameter file " + infoName
                    + " is preceded by letter i and a colon.)";

        JOptionPane.showMessageDialog(jPanelOutput, instruct);
    }
// =========================================================================
    private void showxFile() {
        jTextLoc.setEnabled(false);
        jTextBurr.setEnabled(false);
        jTextBCrit.setEnabled(false);
        jTextXCrit.setEnabled(false);
        jLabelxOut1.setEnabled(false);
        jLabelxOut2.setEnabled(false);
        jLabelxOut3.setEnabled(false);
        int n = methodInd();
        if (n > 0) {
            jCheckXtraOut.setEnabled(true);
            jCheckLocOut.setEnabled(true);
            jLabelLoc1.setEnabled(true);
            jLabelLoc2.setEnabled(true);
            jLabelMisDat.setEnabled(true);
            jButtonRun.setEnabled(true);
            jButtonParamFile.setEnabled(true);
            if (n != 4) {  // NOT only Coancestry method
                jLabelxOut1.setEnabled(true);
                jLabelxOut2.setEnabled(true);
//                jTextXCrit.setEnabled(true);
                // add condition in Oct 2013
                if (jCheckXtraOut.isSelected()) jTextXCrit.setEnabled(true);
            }
            jLabelxOut3.setEnabled(true);
        } else {
            jCheckXtraOut.setEnabled(false);
            jCheckLocOut.setEnabled(false);
            jLabelLoc1.setEnabled(false);
            jLabelLoc2.setEnabled(false);
            jLabelMisDat.setEnabled(false);
            jButtonRun.setEnabled(false);
            jButtonParamFile.setEnabled(false);
        }
        if (jCheckLocOut.isSelected()) {
            jTextLoc.setEnabled(true);
        }
        if (jCheckLD.isSelected()) {
            jCheckBurr.setEnabled(true);
            jLabelBur1.setEnabled(true);
            jLabelBur2.setEnabled(true);
            jLabelBur3.setEnabled(true);
            if (jCheckBurr.isSelected()) {
                jTextBurr.setEnabled(true);
                jTextBCrit.setEnabled(true);
                jTextBurrOut.setEnabled(true);
            }
        } else {
            jCheckBurr.setEnabled(false);
            jLabelBur1.setEnabled(false);
            jLabelBur2.setEnabled(false);
            jLabelBur3.setEnabled(false);
            jTextBurr.setEnabled(false);
            jTextBCrit.setEnabled(false);
            jTextBurrOut.setEnabled(false);
        }
        jTextFieldxLD.setEnabled(false);
        jTextFieldxHet.setEnabled(false);
        jTextFieldxCoan.setEnabled(false);
        jTextFieldxTemp.setEnabled(false);
        if (jCheckXtraOut.isSelected()) {
            if (jCheckLD.isSelected()) jTextFieldxLD.setEnabled(true);
            if (jCheckHet.isSelected()) jTextFieldxHet.setEnabled(true);
            if (jCheckCoan.isSelected()) jTextFieldxCoan.setEnabled(true);
            if (jCheckTemp.isSelected()) jTextFieldxTemp.setEnabled(true);
        }
        setToolTipBurTxt();
        setToolTip(jTextLoc, tipOneRange);
    }
// =========================================================================
    private void xOutputNames() {
        jTextFieldxLD.setText("");
        jTextFieldxHet.setText("");
        jTextFieldxCoan.setText("");
        jTextFieldxTemp.setText("");
        jTextFieldxLD.setToolTipText(null);
        jTextFieldxHet.setToolTipText(null);
        jTextFieldxCoan.setToolTipText(null);
        jTextFieldxTemp.setToolTipText(null);
        String prefix = getPrefix(jTextOutFile.getText(), 0);
        if (prefix.length() > 0) {
            if (jTextFieldxLD.isEnabled() == true) {
                jTextFieldxLD.setText(prefix + "xLD" + outExt);
                jTextFieldxLD.setToolTipText
                        ("Output file name for LD method");
            }
            if (jTextFieldxHet.isEnabled() == true) {
                jTextFieldxHet.setText(prefix + "xHt" + outExt);
                jTextFieldxHet.setToolTipText
                        ("Output file name for Het-Excess method");
            }
            if (jTextFieldxCoan.isEnabled() == true) {
                jTextFieldxCoan.setText(prefix + "xCn" + outExt);
                jTextFieldxCoan.setToolTipText
                    ("Output file name for Molecular Coan. method");
            }
            if (jTextFieldxTemp.isEnabled() == true) {
                jTextFieldxTemp.setText(prefix + "xTp" + outExt);
                jTextFieldxTemp.setToolTipText
                        ("Output file name for Temporal method(s)");
            }
        }
    }

// =========================================================================
    private boolean getIniValues(String iniFile) {
        String inpDir, outDir, genSets;
        String fullName;
        int i;
        int nLines = 10; // nLines are the number of lines need to be read
        String[] lines = new String [nLines];
        for (i=0; i<nLines; i++) lines[i] = "";
        if (samePath) fullName = iniFile;
        else {
            fullName = currPath;
            if (!fullName.endsWith(File.separator)) fullName += File.separator;
            fullName += iniFile;
        }
//        File info = new File (fullName);
        if (!fileExisted(fullName)) return false;   // no initial file to read
        try {
            FileInputStream fstream = new FileInputStream(fullName);
            DataInputStream in = new DataInputStream(fstream);
            BufferedReader br = new BufferedReader(new InputStreamReader(in));
            String line;
            i = 0;
            while ((line = br.readLine()) != null) {
                lines[i] = line;
                i++;
//                System.out.println (line);
                if (i == nLines) break;
            }
            in.close();
        } catch (IOException e) {
            return false;
        }
        // lines[0] for critical values,
        // lines[1] for CI checkbox,
        // lines[2] for input directory
        // lines[3] for output directory
        // lines[4] for Plan and methods for Temporal
        // lines[5] for generation sets
        // add in Oct 2013:
        // lines[6] for including critical value 0 or not
        // lines[7] for which methods to run
        // lines[8] for mating model
        // lines[9] for extra output file
        if (isDirectory(lines[2])) {
            inpDir = lines[2];
        } else inpDir = currPath;
        if (isDirectory(lines[3])) {
            outDir = lines[3];
        } else outDir = inpDir;
        int tpSign = getPositiveInt(lines[4], 0);
        if (tpSign <= 2 && tpSign >= 1) {
            tPlan = tpSign - 1;
            if (tPlan == 0) jLabelPlan.setText("I");
            else jLabelPlan.setText("II");
        }
        tpSign = getPositiveInt(lines[4], 1);
        if (tpSign > 0 && tpSign < 7) tpMethod = tpSign;

        String genSet[] = getGenerations (lines[5], tPlan);
        genSets = "";
        if (genSet[0].charAt(0) == 'E') {   // generation sets error
            if (tPlan == 1) genSets = iniGen;
        } else {    // generation sets are legitimate
            genSets = lines[5];
        }
        // first line is for critical values
        lines[0] = lines[0].replace(',', ' ');  // commas are ignored
        int n = getNumTokens(lines[0]);
        if (n > maxListSize) n = maxListSize;
        String[] critRead = new String[n];
        boolean critOK = true;
        if (n == 0) {
//            critOK = false;
        // change in Oct 2013, allow empty line to be no critical values,
        // so the list will be empty, and 0-value should be checked
            jCheckPcrit0.setSelected(true);
        } else {
            for (i=0; i<n; i++) {
                float myVal = getPosReal(lines[0], i);
                if (myVal < 0) {    // not a valid real number
                    critOK = false;
                    break;
                }
                critRead[i] = roundDec(myVal, nDecimal);
                try {
                    myVal = Float.parseFloat(critRead[i]);
                } catch (NumberFormatException e) {
                    myVal = -1;
                }
                if (myVal < 0 || myVal >= 0.5) {
                    critOK = false;
                    break;
                } else if (myVal == 0) {
                    n = i;
                    break;
                }
            }
        }
        // after this, critRead are rounded to maximum of nDecimal places
        if (critOK) {   // all values are already accepted
            for (i=0; i < n; i++)
                addToList(listPcrit, critRead[i], maxListSize);
        } else {
            for (i=0; i < critVal.length; i++) listPcrit.add(critVal[i]);
        }
        jTextInpFolder.setText(inpDir);
        jTextOutFolder.setText(outDir);
        jTextTemp.setText(genSets);
        i = getPositiveInt(lines[1], 0);
        if (i == 1) jCheckBoxCI.setSelected(false);
        else jCheckBoxCI.setSelected(true);

        // add Oct 2013
        i = getPositiveInt(lines[6], 0);
        if (i == 1) jCheckPcrit0.setSelected(true);
        else jCheckPcrit0.setSelected(false);
        int method = getPositiveInt(lines[7], 0);
        if (method == 0) {  // illegitimate or an 0 for method entry
            jCheckLD.setSelected(true);
            jCheckHet.setSelected(true);
            jCheckCoan.setSelected(true);
            jCheckTemp.setSelected(true);
        } else {
            jCheckLD.setSelected(false);
            jRadioButtonRan.setEnabled(false);
            jRadioButtonMono.setEnabled(false);
            jCheckHet.setSelected(false);
            jCheckCoan.setSelected(false);
            jCheckTemp.setSelected(false);
            jTextTemp.setEnabled(false);
            jButtonTemp.setEnabled(false);
            if (method >=8) {
                jCheckTemp.setSelected(true);
                jTextTemp.setEnabled(false);
                jButtonTemp.setEnabled(true);
                method -= 8;
            }
            if (method >= 4) {
                jCheckCoan.setSelected(true);
                method -= 4;
            }
            if (method >= 2) {
                jCheckHet.setSelected(true);
                method -= 2;
            }
            if (method > 0) {
                jCheckLD.setSelected(true);
                jRadioButtonRan.setEnabled(true);
                jRadioButtonMono.setEnabled(true);
            }
        }
        // for mating model LD
        i = getPositiveInt(lines[8], 0);
        if (i == 0) jRadioButtonRan.setSelected(true);
        else jRadioButtonMono.setSelected(true);
        // for extra output
        i = getPositiveInt(lines[9], 0);
        if (i == 0) jCheckXtraOut.setSelected(false);
        else {
            jCheckXtraOut.setSelected(true);
            jCheckTab.setEnabled(true);
            if (jCheckLD.isSelected()) jTextFieldxLD.setEnabled(true);
            if (jCheckHet.isSelected()) jTextFieldxHet.setEnabled(true);
            if (jCheckCoan.isSelected()) jTextFieldxCoan.setEnabled(true);
            if (jCheckTemp.isSelected()) jTextFieldxTemp.setEnabled(true);
            jCheckTab.setEnabled(true);
            jTextXCrit.setEnabled(true);
        }
        i = getPositiveInt(lines[9], 1);
        if (i == 0) jCheckTab.setSelected(false);
        else jCheckTab.setSelected(true);
// can read next value on the line as getPositiveInt(lines[9], 2) to fill in
// number of top Pcrits and getPositiveInt(lines[9], 3) for population range
// TO be safe, add two lines for those parameters in ini-file and read here
        return true;
    }

// =========================================================================
    public static float getPosReal(String line, int ind) {
    // This is the version of getPositiveInt, but looking for real value
        int k, n;
        String value;
        if (ind < 0) return 0;
        line = line.trim();
        if ((n=line.length()) == 0) return 0;
        for (k = 0; k < n; k++) {
            if (Character.isWhitespace(line.charAt(k))) break;
        }
        if (ind == 0) {
            value = line.substring(0, k);
            try {
                float num = Float.parseFloat(value);
                return num;
            } catch (NumberFormatException e) {
                return -1.0F;
            }
        } else {
            return getPosReal(line.substring(k), ind - 1);
        }
    }

// =========================================================================
    public static String roundDec(float myVal, int nDec) {
	// Accepting real value myVal, return the string representing
        // the value being rounded off to nDec places
        String fmt = "0.";
        int i;
        for (i=0; i<nDec; i++) fmt += "0";
        String roundStr;
        DecimalFormat df = new DecimalFormat(fmt);
        // rounding off by format df:
        roundStr = df.format(myVal);
        // remove trailing zero in string roundStr:
        for (i=roundStr.length()-1;
            i>0 && ((roundStr.charAt(i)=='.')||(roundStr.charAt(i)=='0')); i--)
        if (i > 0) roundStr = roundStr.substring(0, i);
        return roundStr;
    }

// =========================================================================
    public static String roundDec(String myValStr, int nDec) {
	// Accepting string myValStr representing a real number, return:
	// * the string where the value was rounded off to nDec places
	// * "0" if something wrong.
        String roundStr;
        try {
            float myVal = Float.valueOf(myValStr).floatValue();
            roundStr = roundDec(myVal, nDec);
        } catch (NumberFormatException nfe){
            roundStr = "0";
        }
        return roundStr;
    }

// =========================================================================

    private void saveSetup(String iniFile) {
        // Save setting-upon the form to file named iniFile
        String fullName;
        int lineNumber = 10;
        int i;
        String[] lines = new String[lineNumber];
        for (i=0; i<lineNumber; i++) lines[i] = "";
        // store temploral plan and methods on the 5th line
        lines[4] = (tPlan + 1) + "  " + tpMethod;
        lines[4] += " \t * Which plan and clue for which temporal method(s).";
        lines[4] += " Next line is for generation sets";
        String generations = jTextTemp.getText().trim();
        // Line 6 for storing generations displayed
        lines[5] = displayGeneration(generations, tPlan, false);
        // Critical values on the list are stored on the first line
        int n = listPcrit.getItemCount();
        for (i=0; i<n; i++) {
            if (i > 0) lines[0] += "  ";
            lines[0] += listPcrit.getItem(i);
        }
        lines[0] += "  0 \t * Positive Critical values, ends by a zero-value";
        // store if confidence interval is needed or not on the 2nd line
        lines[1] = "1";
        if (jCheckBoxCI.isSelected()) lines[1] = "0";
        lines[1] += " \t* CI or not, next 2 lines are input and output folders";
        // Lines 3, 4 for storing input, output directories
        lines[2] = jTextInpFolder.getText();
        lines[3] = jTextOutFolder.getText();
// added Oct 2013
        lines[6] = "0";
        if (jCheckPcrit0.isSelected()) lines[6] = "1";
        lines[6] += " \t* Include 0-value as critical value or not";
        lines[7] = "";
        int method = 0;
        if (jCheckLD.isSelected()) method += 1;
        if (jCheckHet.isSelected()) method += 2;
        if (jCheckCoan.isSelected()) method += 4;
        if (jCheckTemp.isSelected()) method += 8;
        lines[7] += method;
        lines[7] += " \t* method(s)";
        if (jRadioButtonRan.isSelected()) lines[8] = "0";
        else lines[8] = "1";
        lines[8] += " \t* LD mating model";
        // for tabular-format output:
        if (jCheckXtraOut.isEnabled() && jCheckXtraOut.isSelected()) {
            lines[9] = "1";
        } else lines[9] = "0";
        if (jCheckTab.isSelected()) lines[9] += "  1";
        else lines[9] += "  0";
        lines[9] += " \t* Tabular-format output file or not, ";
        lines[9] += "with tab-delimiter or not";
        if (samePath) fullName = iniFile;
//        else fullName = currPath + File.separator + iniFile;
        else {
            fullName = currPath;
            if (!fullName.endsWith(File.separator)) fullName += File.separator;
            fullName += iniFile;
        }
        try {
            FileWriter fstream = new FileWriter(fullName);
            BufferedWriter out = new BufferedWriter(fstream);
            for (i=0; i < lineNumber; i++) {
                out.write (lines[i]);
                out.newLine();
            }
            out.close();
        } catch (IOException e) {
// do nothing
        }
    }

// =========================================================================
    private String getInstruct() {
        String instr;
        instr = "'Populations' in input file are 'samples' taken at different" +
                " generations," + newline + "specified by generation sets." +
                " Each generation set corresponds to a " + newline +
                "'distinct population'" +
                " sampled at generations that are given in the set." + newline +
                "Generations in a set must consist of at least 2 numbers " +
                "in ascending order," + newline + "separated by commas or" +
                " blanks. Use a slash  '/'  to separate 2 sets." + newline +
                "The last set applies to the rest of the input file." + newline;
        instr += newline + "For Plan I, census population size N followed " +
                "by a colon should precede" + newline + "generations, to "
                + "constitute a complete generation set. A colon must be"
                + newline + "present in a set for Plan I if N is given.   " +
                "In the absence of N, N is assumed"
                + newline + "the value from the previous set.   "
                + "In the absence of generations after the" + newline +
                "colon, generations are assumed the previous ones."
                + newline +
                "For plan II, no N should be given; colon is only allowed " +
                "if it is a sole colon"  + newline +
                "between slashes to indicate the set is the same as"
                + " the previous one." + newline;

        instr += newline + "Examples: suppose input file has 20 samples." +
                newline + ">  Assuming Plan II and input in the box is:" +
                "       0,1 / : / : / : / 0,1,2" + newline +
                "    This is the same as:" +
                "           0,1 / 0,1 / 0,1 / 0,1 / 0,1,2" +  newline +
                "    Then the first 8 samples are taken at" +
                " generations 0, 1 alternately (4 pops)." + newline +
                "    The rest, 12 samples, are taken at" +
                " generations 0, 1, and 2   (4 pops)." + newline +
                "    Total number of 'distinct' populations is 8.";
        instr += newline + ">  Assuming Plan I and input in the box is:" +
                "    1000: 0,1 / 0,2/ 500: / : / 0,1,3" + newline +
                "    It is the same as:" +
                "     1000: 0,1 / 1000: 0,2 / 500: 0,2 / 500: 0,2 / 500:0,1,3"
                + newline +
                "    Then samples 1, 2 are taken at generations" +
                " 0, 1,  census size N = 1000." + newline +
                "    Samples 3, 4 are taken at generations 0, 2 with" +
                " same N = 1000."
                + newline +
                "    The next 4 samples are taken at generations 0, 2," +
                "  census size N = 500." + newline +
                "    The rest, 12 samples, are taken at generations" +
                " 0, 1, and 3 with N = 500.";
        return instr;
    }

// =========================================================================

    private String reduceStr (String toReduce, char c) {
    // on input, the string toReduce is supposed to contain several tokens
    // (a token is a string without white spaces, so two tokens are separated
    // by one or more white spaces),
    // The return value is a string consists of tokens in toReduce, all
    // white spaces between two tokens are replaced by one c as a separator
    // -------------------------------------------------------------------
        if (toReduce.length() == 0) return toReduce;
        String reduced = toReduce.trim();
        for (int j=0; j<reduced.length(); ) {
            if (Character.isWhitespace(reduced.charAt(j))) {
                int k = j;
                String pre = reduced.substring(0, k);
                while (Character.isWhitespace(reduced.charAt(j))) j++;
                // at position k, reduced is a white space
                reduced = pre + c + reduced.substring(j);
                j = k+1;    // pre has length k, so c is at index k of
                            // the new reduced
            } else j++;
        }
        return reduced;
    }

// =========================================================================

    private static void addToList (java.awt.List list1,
                        String myValStr, int maxsize) {

        int size = list1.getItemCount();
        if (size >= maxsize && maxsize > 0) return;	// no adding if list1
        					// already has maxsize items, and maxsize > 0
        float mynum = 0;
        float myVal = Float.valueOf(myValStr).floatValue();
        int i;
        // if the list was empty, mynum is still 0 after the next loop
        for (i=0; i<size; i++) {
            mynum = Float.valueOf(list1.getItem(i)).floatValue();
            if (mynum <= myVal) break;
        }
        // only add if this is a new item:
        if (mynum != myVal) list1.add(myValStr, i);
    }

// =========================================================================
    private String getLociInst() {
        String instr;
        instr = "Numbers for '" + jRadioButtonDel.getText() +
                "' are separated by" + " commas/blanks." + newline +
                "The '" + jRadioButtonRange.getText() + "' textbox may consist"
                + " of both ranges and single loci," + newline +
                "and should be separated by blanks or commas." + newline +
                "A range consists of two numbers separated by at least a dash."
                + newline + "Rules:" + newline + "1. Loci numberings " +
                "must be valid positive integers, at most 10^5." +
                newline + "2. Two entries making up a range " +
                "must be in ascending order." + newline +
                "3. Cannot have one number between two dashes." + newline
//                + "4. Cannot have both dash and comma between 2 numbers."
//                + newline
                + newline + "Examples: each of the following " +
                "[enclosed by squared brackets]" + newline +
                "    [2-5,10,14-20]   [2 -  5  ,  10 14     -20]     in '" +
                jRadioButtonRange.getText() + "' textbox" + newline +
                "means that only loci 2 to 5, 10, and 14 to 20, are accepted.";
        return instr;
    }

// =========================================================================

    private static String getRange(String line, boolean isRange, int entry) {
// On input, line should be a string consisting of digits, blanks, dashes,
// and commas ONLY. The conditions were established by event KeyReleased
// which erases outside characters.

// A legitimate range consists of two integers in ascending order separated
// by at least a dash and possibly blanks, nothing else; so a "dash"
// can mean it consists of dashes mixing with blanks.
// Two ranges or a range and a single number should be separated by a
// blanks or a "comma". As for dash, a "comma" may consist of commas
// mixing with blanks.
// When called, should set isRange = false. When isRange = true, it is
// obligated that the first number of line must be the end of a range.
// When there is an error, the return string includes a sentence,
// which consists of letter 'E'.
//
// String "line" should represent several ranges of positive numbers
// (the requirement for positive is realized by calling getPositiveInt).
// However, cannot have both commas and dashes between two numbers.
// The line should start with a number (no commas, dashes). When the method
// is called, this condition is fulfilled by event KeyReleased.
// Return value is a string of pairs of numbers, numbers in a pair are
// separated by exactly one blank, two consecutive pairs are also separated
// by exactly one blank.
// Each pair represents a range. For example, with line being:
// 1,,,   3 --5,   7-10
// (single number 1, then 3 to 5, then 7 to 10), the return value should be
// 1 1 3 5 7 10

// Parameter 'entry' to keep track of what entry is in consideration at
// each call of this method. When this method is called, this parameter
// should be set equals to 1. (At each successive recursive call, this
// value is incremented by 1.)
        int i, k, n;
        char c, d;
        // The error string for returning value when "line" contains error.
        // Rule 1: invalid number (too large), Rule 3: dashes on both sides
        // of a number, Rule 4: both dashes and commas between two numbers.
        // Rule 2 is not detected (2 numbers for a range must be ascending).
        String rule1Err = "Error at Range: Rule 1 is violated.";
        String rule3Err = "Error at Range: Rule 3 is violated.";
        // Code was modified to prevent the range textbox from having both
        // dash, comma between 2 numbers, so rule 4 will not happen
        // (Rule 4 stated in getLociInst method was commented out.)
        String rule4Err = "Error at Range: Rule 4 is violated.";
        String ranges;
        String firstNum;
        int m;
        line = line.trim();
        n = line.length();
        // Since we don't care about any characters at the rear end
        // (i.e. not followed by any number), which means those are not
        // considered as an error, then we should erase those unneeded chars
        // (by truncating string line from the right).
        // Doing this will make the code simpler. If want to report error
        // on some nondigit characters at the rear, can still doing so by
        // first checking if criterion for non-error is met on these
        // characters, then still erase all, so that the remaining code
        // are still valid.
        // At subsequent calls by recursive, this "for" loop exits immediately
        for (i = n-1; i >=0; i--) {
            c = line.charAt(i);
            if (digits.indexOf(c) != -1) break;
        }
        n = i+1;
        line = line.substring(0, n);    // truncate string line from the right
        if (n == 0) return "";
        // so now n > 0 and charAt(n-1) must be a digit.

        // should start a line with a digit
        // This is always true at Range textbox when this is first called
        // since it is taken care by event KeyReleased, which erases anything
        // not a number in front.
        // If that is not done from KeyReleased, then should skip until
        // a digit is met (note that charAt(n-1) is a digit).
        // In recursive calls, should make sure there must be digit in front
        // of the string parameter.

        // However, in recursive call, it might be a comma or dash.

        c = line.charAt(0);
        i = 0;
        while (i < n && digits.indexOf(c) != -1) {
            i++;
            if (i < n) c = line.charAt(i);
        }
        k = i;
        // Now character at index k is non-digit c, and at index < k is digit.
        // Since it is non-digit, c must be blank, comma, or dash.
        firstNum = line.substring(0, k);    // k is the length of firstNum
        m = getPositiveInt(maxInt, firstNum);
        // firstNum now is not to be used except to report error, where
        // the error message will contain firstNum. To avoid a long string
        // showing (note that even the value m of firstNum is not too big,
        // but the string firstNum may contain a lot of leading zeros),
        // we truncate a bit, not to report more than 10 chars:
        // (put "..." but no blank because this message will be modified
        // by finalRanges, where a blank will stop the display)
        if (k > 10) firstNum = "..." + firstNum.substring(k-10, k);
        // since original firstNum consist of only digits, this can only
        // happen if the number exceeds int or firstNum has only zeros:
        if (m <= 0) return firstNum + rule1Err + " (Entry " + entry + ")";
        // again because of possible leading zeros in firstNum, convert m:
        String mStr = String.valueOf(m);
        if (k == n) {   // firstNum is line, so nothing left
            ranges = mStr;
            if (!isRange) ranges += " " + mStr;
            return ranges;
        }
        // k now < n, i.e., the previous "while" loop yields c = line.charAt(k),
        // and that c is not a digit (since k < n),
        // so c should be a blank, comma, or dash, which follows firstNum
        if (Character.isWhitespace(c)) {
        // continue until getting a non-blank char. There must be a digit
        // behind c, since from previous "for" loop, charAt(n-1) is a digit,
        // so the following loop must terminate at some i < n:
            for (i=k; i<n; i++) {
                c = line.charAt(i);
                if (!Character.isWhitespace(c)) break;
            }
        }
        // reset k:
        k = i;  // we should have k < n
        // Now c is at index k, and is the first non-blank after firstNum,
        // c is either a comma, a dash or a digit.
        // However, if the statement "if (Character.isWhitespace(c))" is
        // not executed, c is not blank, so can only be a comma or a dash.
        if (digits.indexOf(c) != -1) { // the "if" statement above was
            // executed, there are only blanks between m and the next number,
            // which then cannot be the end of a range (false in recursive call)
            line = line.substring(k);   // k < n and c = charAt(k) is digit,
                        // so the reasigned value "line" starts with digit c.
            ranges = mStr + " " + getRange(line, false, entry+1);
            if (!isRange) ranges = mStr + " " + ranges;
        } else {    // don't know whether the "if" statement above was
                    // executed, only know that c is comma or dash.
            d = c;  // Now, search for another non-blank, non-c.
            // There should be one since charAt(n-1) is a digit, and k < n.
            for (i=k; i<n; i++) {
                d =line.charAt(i);
                if (!Character.isWhitespace(d) && d != c) break;
            }
            k = i; // index where a non-blank d != c is seen,
            // Now, if d is not a digit, we have both comma and dash (c and d)
            // between m and the next number, so it should be an error
            if (digits.indexOf(d) == -1) {
                return firstNum + c + d + rule4Err + " (Entry " + entry + ")";
            } else {    // d is a digit, and only characters = c or blanks
                // are between m and the next number (which starts by d)
                line = line.substring(k);
                if (c == ',') { // next number should not be the end of a range
                    ranges = mStr + " " + getRange(line, false, entry+1);
                    if (!isRange) ranges = mStr + " " + ranges;
                } else {    // the number after m should be the end of range, so
                    // so m must not be (error if isRange is true).
                    if (isRange) ranges = c + firstNum + c +
                            rule3Err + " (Entry " + entry + ")";
                    else ranges = mStr + " " + getRange(line, true, entry+1);
                }
            }
        }
        return ranges;
    }

// =========================================================================
// NOT USED
    private String skipTokens(String line) {
// return line with the first token removed
        if (line.trim().length() == 0) return "";
        String first = getFirstToken(line);
        int k = first.length();
        return line.substring(k).trim();
    }

// =========================================================================
// No longer Used (was used in finalRanges)

    private String revisedRange(String line) {
    // string line is supposed to be a string of positive integers,
    // which can be grouped in pairs. Each pair represents a range of positive
    // integers. The numbers should be in ascending order.
    // If the ascending order property is violated, a string of error message
    // (with a letter E) will be included in the return value.
    // The method  also combines consecutive ranges in one range if together
    // they represent consecutive numbers, then return the revised ranges.

        // don't need to do a thing if already error
        if (line.indexOf('E') != -1) return line;
        String revised;
        line = line.trim();
        String rule2Err = "Error at Range, Rule 2 is violated.";
        if ("".equals(line)) return line;
        int n = getNumTokens(line);
        String first = getFirstToken(line);
// unnecessary: all are valid numbers since this will be called after getRange
//        if (getPositiveInt(first) <=0) return rule2Err;
        revised = "";
        boolean add = true;
        for (int i=0; i<n; i++) {
            line = line.substring(first.length()).trim();
            if (line.equals("")) break; // this happens only when i = n-1.
            // We can remove it by setting condition i < n-1 at the loop.
            String second = getFirstToken(line);
            if (getPositiveInt(second) < getPositiveInt(first))
                return (first + " > " + second + ": " + rule2Err);
            // The next block of code is for combining ranges.
            // For example, 1  2  3  5: two ranges [1, 2], [3, 5] will be
            // combined in one range, 1  5.
            // When i is odd, previous 'first' and this 'first' are the
            // beginning and the end of a range. (In the above example, at
            // i=1, previous first is 1, this first is 2, this second is 3.)
            // If this second is within 1 of this first, then we can combine
            // with the next range, therefore, we should not add the range
            // end yet at this step (i.e. this first is not added).
            // Then to make sure at (i+1) even, 'first' (at i+1) = 'second'
            // (at i) should not be added, we set add=false to apply to (i+1).
            // Variable add is given true except at the index i that follows
            // the condition allowing ranges to be combined.
            if ((i % 2 == 1) &&
                    (getPositiveInt(second) <= getPositiveInt(first) + 1))
                add = false;
            else {
                if (add) revised += first + " ";
                add = true;
            }
            first = second;
        }
        revised += first;
        return revised;
    }
// =========================================================================
    private static String finalRanges(String line) {
        String range = getRange(line, false, 1);
        int k;
        if ((k = range.indexOf('E')) != -1) {
        // The error is a token of non-blanks before the character E
        // in the string range
            int i = k;
            while ((i >= 0) && (!Character.isWhitespace(range.charAt(i)))) i--;
            i++;
            return range.substring(i, k) + " < " + range.substring (k);
        }
        // in the next call, if error, the returning string is good for
        // reporting, so don't need to modify as above
        range = arrange(range, false);
        range = combineRange(range);
// don't use revisedRange anymore, so block out here
/*
        range = revisedRange(range);
        if (range.indexOf('E') != -1) return range;
//            return "Error in format for 'Range'";
        // now the format is OK, range is either empty or consists of pairs,
        // but still need to check if it contains at least 2 loci:
//*/
        if (getNumTokens(range) == 2) {
            int i = getPositiveInt(range, 0);
            int j = getPositiveInt(range, 1);
            if (j <= i) range = i + "-" + j +
                    ": Error, Range should contain at least 2 loci";
        }
        return range;
    }
// =========================================================================
    private static String arrange(String range, boolean checked) {
        // set checked = false when called, to check for range error
        // This should be called after getRange, so that range consists
        // of pairs of valid positive integers. All numbers are separated
        // by exactly one blank. The returning string is an arrangement
        // of ranges, where the pairs are ordered based on the value of
        // the first one in a pair.
        String rule2Err = "Error at Range, Rule 2 is violated.";
        range = range.trim();   // trim to make sure no blanks in front
        String reduced = range;
        int dblTokens = getNumTokens(range)/2;
        if (dblTokens == 0) return range;
        int minInd = 0, maxInd = 0;
        int smallest = maxInt;
        int startInd, endInd = -1;
        // a pair of tokens spreads from index startInd, to index (endInd-1)
        // choose the pair that the first one is smallest, to put in front
        for (int i = 0; i < dblTokens; i++) {
            String token = getFirstToken(reduced);
            int n = token.length();
            reduced = reduced.substring(n).trim();
            String next = getFirstToken(reduced);
            int m = next.length();
            startInd = endInd + 1;
            endInd += (n+m+2);
            int first = getPositiveInt(token);
            if (!checked) {
                int second = getPositiveInt(next);
                if (second < first)
                    return first + " > " + second + ": " + rule2Err +
                            " (Block " + (i+1) + ")";
            }
            if (first >= 0 && first < smallest) {
                smallest = first;
                minInd = startInd;
                maxInd = endInd;
            }
            reduced = reduced.substring(m).trim();
        }
        // now, substring of range from index minInd upto index (maxInd-1)
        // is the pair where the first one is smallest.
        // Always trim to preserve exactly on blank between tokens
        String firstPair = range.substring(minInd, maxInd).trim();
        // reduced range, it now may have a blank in front
        reduced = range.substring(0, minInd).trim() + " " +
                    range.substring(maxInd).trim();
        // now add back one blank to separate pairs
        range = firstPair + " " + arrange(reduced, false);
        return range;
    }


// =========================================================================

    private static String combineRange(String range) {
    // expect range consists of pairs of numbers, output from arrange,
    // where the pairs are ordered based on the first number of pairs
        if (range.indexOf('E') != -1) return range;
        String reduced = range;
        int nTokens = getNumTokens(range);
        if (nTokens <= 2) return range;
        // at least there are 4 tokens
        // first one, to be ignored:
        String firstPair = getFirstToken(reduced);
        int n = firstPair.length();
        reduced = reduced.substring(n).trim();
        // second one, take value
        String next  = getFirstToken(reduced);
        int first = getPositiveInt(next);
        n = next.length();
        reduced = reduced.substring(n).trim();
        // third one, take value, which is the beginning of the 2nd range
        String token  = getFirstToken(reduced);
        int second = getPositiveInt(token);
        if (second > first + 1) {   // the first pair cannot be combined
            firstPair += " " + next;
            return firstPair + " " + combineRange(reduced);
        }
        // now can combine two pairs in one
        n = token.length();
        reduced = reduced.substring(n).trim();
        // the end of the second pair:
        token  = getFirstToken(reduced);
        second = getPositiveInt(token);
        n = token.length();
        reduced = reduced.substring(n).trim();
        // now, combine the first two pairs into one pair,
        // and put that to reduced as a first pair of the combined string.
        // This means, replace the first two pairs in the original
        // by this comined pair:
        if (second > first) firstPair += " " + token;
        else firstPair += " " + next;
        return combineRange(firstPair + " " + reduced);
    }

// =========================================================================

    private static String editedRange(String range) {
    // from range as a string of pairs of integers, return a string
    // representing range with commas and dashes (no blanks)
        String revised = range;
        int nTokens = getNumTokens(range);
        if (nTokens <= 1) return range;
        String token = getFirstToken(revised);
        int n = token.length();
        revised = revised.substring(n).trim();
        String next = getFirstToken(revised);
        n = next.length();
        revised = revised.substring(n).trim();
        String replace;
        if (getPositiveInt(token) == getPositiveInt(next)) replace = token;
        else replace = token + "-" + next;
        if (nTokens > 2) replace += ",";    // more pairs after
        return (replace + editedRange(revised));
    }
// =========================================================================
    private int numInRange(String revisedR, int maxLoc) {
	// assuming on input, rangeText is supposed to be ranges of numbers.
	// containing pairs of integers, which are separated by one blank.
        // The method returns the number of elements determined by these
        // ranges, whose endpoints are bounded by maxLoc.
        // Unlike its cousin (difference in the second parameter), string
        // parameter here was the output of method finalRanges
	if (revisedR.length() == 0)  return 0;
        if (revisedR.indexOf('E') != -1) {
            return -1;
        } else {
            String edited = editedRange(revisedR);
            // edited contains ranges (specified by a dash between 2 numbers)
            // separated by commas, no blamks. Now, to count the total number
            // of loci, replace commas by blanks so that we can count the
            // total number of ranges.
            // Then for each range, which is a token, clear the dash to break
            // it into 2 tokens so that we know the number in the range.
            String noComma = edited.replace(',', ' ');
            // the difference between noComma and revisedR is that
            // string noComma carries dashes, but revisedR has no dash.
            // (e.g. revisedR = "1 3 5 7" and noComma = "1-3 5-7")
            int n = getNumTokens(noComma); // n ranges
            int k = 0;
            for (int i =0; i < n; i++) {
                String range = getFirstToken(noComma);
                range = range.replace('-', ' ');
//                if (getNumTokens(range) == 1) k++;
//                else {
                if (getNumTokens(range) > 1) {
                    String first = getFirstToken(range);
                    String second = range.substring(first.length()+1);
                    int p = getPositiveInt(first);
                    int q = getPositiveInt(second);
                    if (p > maxLoc) break;
                    if (q > maxLoc) q = maxLoc;
                    int j = getPositiveInt(second) - getPositiveInt(first) + 1;
                    k += j;
                    if (q == maxLoc) break;
                }
                if (i < n-1) noComma = noComma.substring(range.length()+1);
            }
            return k;
        }
    }
// =========================================================================
    private static int numInRange(String rangeText, StringBuilder display) {
	// assuming on input, rangeText is supposed to be ranges of numbers.
	// contain the word "Error", or consists of legitimate ranges specified
	// by pairs of positive integers. There is one blank betwen two numbers.
	// Call finalRanges, which evaluate if rangeText is legitimate,
        // and if it is, makes it ontain pairs of integers. The numbers are
        // separated by one blank.
        String revisedR = finalRanges(rangeText);
	if (revisedR.length() == 0)  return 0;
        if (revisedR.indexOf('E') != -1) {
            display.append(revisedR);
            return -1;
        } else {
            String edited = editedRange(revisedR);
            // edited contains ranges (specified by a dash between 2 numbers)
            // separated by commas, no blamks. Now, to count the total number
            // of loci, replace commas by blanks so that we can count the
            // total number of ranges.
            // Then for each range, which is a token, clear the dash to break
            // it into 2 tokens so that we know the number in the range.
            String noComma = edited.replace(',', ' ');
            // the difference between noComma and revisedR is that
            // string noComma carries dashes, but revisedR has no dash.
            // (e.g. revisedR = "1 3 5 7" and noComma = "1-3 5-7")
            int n = getNumTokens(noComma); // n ranges
            int k = 0;
            for (int i =0; i < n; i++) {
                String range = getFirstToken(noComma);
                range = range.replace('-', ' ');
                if (getNumTokens(range) == 1) k++;
                else {
                    String first = getFirstToken(range);
                    String second = range.substring(first.length()+1);
                    int j = getPositiveInt(second) - getPositiveInt(first) + 1;
                    k += j;
                }
                if (i < n-1) noComma = noComma.substring(range.length()+1);
            }
            if (edited.length() < rangeText.length()) display.append(edited);
            return k;
        }
    }

// =========================================================================

    private int numLocDel(String revised, int maxLoc) {
        // Unlike its cousin (difference in the second parameter), string
        // parameter here was the output of method revisedLocDel,
        // which consist of numbers in ascending order, only one blank
        // separating 2 numbers
        if (revised.length() != 0) {
        // there are entries in textbox jTextLocDel
            if (revised.indexOf('E') == -1) {
                int n = getNumTokens(revised);
                int k = 0;
                for (int i = 0; i < n; i++) {
                    if (getPositiveInt(revised, i) > maxLoc) break;
                }
                return k;
            }
            else return (-1);
        } else return 0;
    }
// =========================================================================

    private int numLocToRun(String locText, int maxLoc, boolean range) {
        if (range) return (numInRange(locText, maxLoc));
        else return (maxLoc - numLocDel(locText, maxLoc));

    }
// =========================================================================

    private int numLocDel(String content, StringBuilder display) {
        String locText = content.replace(',', ' ');
        // This revised rearrange locText in ascending order, only one blank
        // separating 2 numbers
        String revised = revisedLocDel(locText, false);
        if (revised.length() != 0) {
        // there are entries in textbox jTextLocDel
            if (revised.indexOf('E') == -1) {
                int n = getNumTokens(revised);
                if (revised.length() < content.length()) {
                    revised = revised.replace(' ', ',');
                    display.append(revised);
                }
                return n;
            } else {    // error, revised contains the message
                display.append(revised);
                return (-1);
            }
        } else return 0;
    }
// =========================================================================
    private int getTempMethods() {
        String pk = "Pollak", nt = "Nei/Tajima", jr = "Jorde/Ryman";
        String plan1 = ", Plan I";
        String plan2 = ", Plan II";
        Object[] methods = {tempMethod[0]+plan1, tempMethod[1]+plan1,
                            tempMethod[2]+plan1, tempMethod[3]+plan1,
                            tempMethod[4]+plan1, tempMethod[5]+plan1,
                            tempMethod[6]+plan1, tempMethod[0]+plan2,
                            tempMethod[1]+plan2, tempMethod[2]+plan2,
                            tempMethod[3]+plan2, tempMethod[4]+plan2,
                            tempMethod[5]+plan2, tempMethod[6]+plan2};
        int currInd = tpMethod + 7*tPlan;
        String msg = "Choose one or more of the three temporal" +
                newline + "methods: "  + pk + ", " + nt + ", " + jr + "." +
                newline + "(Current: " + methods[currInd] + ".)";
        // put the dialog box at center of Critical Values Panel:
        Object selectedValue = JOptionPane.showInputDialog(jPanelPcrit, msg,
                "Temporal Methods", JOptionPane.INFORMATION_MESSAGE, null,
                methods, methods[currInd]);
        int i = tpMethod;
        if (selectedValue != null) {
            for (i=0; i < methods.length; i++) {
                if (selectedValue.equals(methods[i])) break;
            }
            if (i >= 7) {
                tPlan = 1;
                i -= 7;
                jLabelPlan.setText("II");
            }
            else {
                tPlan = 0;
                jLabelPlan.setText("I");
            }
            String tipText = selectedValue.toString();
            int j = tipText.indexOf(',');
            jCheckTemp.setToolTipText(tipText.substring(0,j));
        }
        return i;
    }
// =========================================================================

    private boolean changeDirToGetInput (javax.swing.JTextField jTextFolder)
    {
// assuming the text in jTextFolder contains the name of a directory,
// pop up a dialog box to choose a file, put its directory into jTextFolder.
// Return true if the current text for a directory is changed.
        UIManager.put ("FileChooser.fileNameLabelText", "File Name:");
        String theDirectory = jTextFolder.getText().trim();
        String oldDirectory = theDirectory;
        if (!isDirectory(theDirectory)) return false;
        JFileChooser fileChooser = new JFileChooser(theDirectory);
        setNoEditText(fileChooser);
        fileChooser.setDialogTitle("Choose Input File");
        fileChooser.setApproveButtonText("Choose file");
        fileChooser.setFileSelectionMode(JFileChooser.FILES_ONLY);
//        JFrame frame = new JFrame();
//        int result = fileChooser.showOpenDialog(frame);
        // put the file dialog in the center of output panel:
        int result = fileChooser.showOpenDialog(jPanelOutput);
        String fileName = "";
        switch (result) {
            case JFileChooser.APPROVE_OPTION:
                File fullName = fileChooser.getSelectedFile();
                theDirectory = fullName.getParent();
                jTextFolder.setText(theDirectory);
                fileName = fullName.toString().substring(theDirectory.length());
                // fileName may start with a file separator when this file
                // is not in the root directory
                int i = 0;
                while (fileName.charAt(i) == File.separatorChar) i++;
                fileName = fileName.substring(i);
                break;
            case JFileChooser.CANCEL_OPTION:
                return false;
            case JFileChooser.ERROR_OPTION:
                return false;
        }
        int size = endsBy.length;
        String fileU = fileName.toUpperCase();
        int k = 0;
        // check if chosen file has extension listed in endsBy. If not,
        // should uncheck checkbox for those extensions.
        for (; k < size; k++) {
        if (endsBy[k].length() == 0) continue;
            if (fileU.endsWith(endsBy[k])) break;
        }
        if (k >= size) jCheckFileType.setSelected(false);
        loadFilesToCombo(theDirectory, jComboBoxFile,
                endsBy, jCheckFileType.isSelected());
        for (k = 0; k < jComboBoxFile.getItemCount(); k++) {
            if (fileName.equals(jComboBoxFile.getItemAt(k).toString()))
            break;
        }
        // setSelectedIndex triggers event jComboBox1ActionPerformed
        if (k >= 0 && k < jComboBoxFile.getItemCount())
            jComboBoxFile.setSelectedIndex(k);
        else jComboBoxFile.setSelectedIndex(-1);
        // if there is a change in directory, return true
        if (oldDirectory.trim().equals(theDirectory)) return false;
        else return true;
    }
// =========================================================================
    private void chooseInput() {
        if (!changeDirToGetInput(jTextInpFolder)) return;
        String theDirectory = jTextInpFolder.getText();
        // if output folder never changed by the user, default to input folder:
        if (!setOutFolder) jTextOutFolder.setText(theDirectory);
    }

// =========================================================================

    private int getNumPopOut(String popRun, String popOut, int nPop, int maxPop)
    {
    // String popRun is assumed to be the range of populations to run
    // String popOut is assumed to be the range of populations for output
    // either in Freq. Data output or Burrow output.
    // nPop is the number of pops, recorded by form-level variable numPop
    // maxPop is the maximum number of pops that can output (Freq. or Burrow)
    // On input, nPop = 0 indicates there is no info on the number of
    // populations in input file yet.
        int totPop = nPop;
        int startPopRun = 1;
        int endPopRun = nPop;
        if (popRun.trim().length() > 0) {
            popRun = popRun.replace('-', ' ');
            if (getNumTokens(popRun) == 1) {
                startPopRun = getPositiveInt(popRun);
                endPopRun = startPopRun;
                if (nPop > 0 && startPopRun > nPop) totPop = 0;
                else totPop = 1;
            } else {
                startPopRun = getPositiveInt(popRun, 0);
                endPopRun = getPositiveInt(popRun, 1);
                if (nPop > 0 && endPopRun > nPop) endPopRun = nPop;
                totPop = endPopRun - startPopRun + 1;
            }
        }
        if (nPop > 0 && totPop <= 0) return 0;  // no population to run
        // now do the same for popOut:
        if (popOut.trim().length() == 0) {  // no entry, assuming max
            if (nPop > 0 && totPop < maxPop) return totPop;
            else return maxPop;
        } else {
            popOut = popOut.replace('-', ' ');
            if (getNumTokens(popOut) == 1) {
                int startPopOut = getPositiveInt(popOut);
                if ((startPopOut < startPopRun) ||
                        (nPop > 0 && startPopOut > endPopRun)) return 0;
                else return 1;
            } else {
                int startPopOut = getPositiveInt(popOut, 0);
                int endPopOut = getPositiveInt(popOut, 1);
                if (nPop > 0 && endPopOut > endPopRun) endPopOut = endPopRun;
                if (startPopOut < startPopRun) startPopOut = startPopRun;
                int nOut = endPopOut - startPopOut + 1;
                if (nOut < 0) nOut = 0;
                return nOut;
            }
        }
    }

// =========================================================================

    private long getBurrSize(int loci, int nPop, int maxPop) {
    // approximate Burrow file size in terms of GB, assuming
    // about (1/2)(loci*(loci-1)) lines, each line contains 100B
        if (!jCheckBurr.isSelected()) return 0;
    // each pair of loci for r2-coeff occupies about 100 characters on a line,
    // so for (loci) loci, the number of bytes is approx. (loci)*(loci)*50.
    // If we set burr = loci*(loci*50), then the right side perform in integer
    // type, which then overflows the capacity of an integer, so need to break
    // the arithmetic in two steps:
        long longLoc = loci*50;
        long burr = ((long) loci)*longLoc;  // for 1 pop, 1 critical value.
        int nPopOut = getNumPopOut(jTextPop.getText(), jTextBurr.getText(),
                                    nPop, maxPop);
        if (nPopOut <= 0) return 0;
        String critStr = jTextBCrit.getText().trim();
        int critNum = listPcrit.getItemCount() + 1;

        if (critStr.length() > 0) {
            int critB = getPositiveInt(critStr);
            if (critB < critNum) critNum = critB;
            if (critB == 0) critNum = 1;  // only critical value 0 is taken;
        }
        burr *= (nPopOut*critNum); // file size in bytes
        return burr;
    }

// =========================================================================
    private boolean acceptBurrSize(int nLoci, int nPop, int maxPop) {
    // return true: go ahead to run and create Burrow Output as wanted
        if (!jCheckBurr.isSelected()) return true;
        String outFolder = jTextOutFolder.getText().trim();
//        File f = new File(".");
        File f = new File(outFolder);
// f.getUsableSpace() gives available space in bytes (long)
        long availInBytes = f.getUsableSpace();
        float avail = (float) availInBytes;
        long burr = getBurrSize(nLoci, nPop, maxPop);
        if (burr == 0) return true;
        float burrSize = (float) burr;
        float ratio;

        if (avail > 0) ratio = burrSize/avail;
        else ratio = 0; // if file "f" above is not defined, avail = 0!
        boolean noRun = (ratio >= maxRatio);
        boolean warning = (ratio >= sizeLim);
        float burrInMB = burrSize/(10e6F);
        float availInMB = avail/(10e6F);
        float burrInGB = burrSize/(10e9F);
        float availInGB = avail/(10e9F);
        String availStr = roundDec(availInGB, nDecimal) + " GB";
        if (avail == 0) availStr = "unknown";
        else if (availInGB <= 0.5) availStr = roundDec(availInMB, 1) + " MB";
        String burrStr = roundDec(burrInGB, nDecimal) + " GB";
        if (burrInGB <= 0.5) burrStr = roundDec(burrInMB, 1) + " MB";
        String msg = "The size of Burrow Output file may be around " +
                    burrStr + newline + "Available space is " +
                    availStr + newline;
        if (noRun) {
            msg += "The size of Burrow output is too large for available space"
                    + " (ratio >= " + roundDec(maxRatio, 2) + ")." + newline
                    + "If possible, decrease number of populations and"
                    + newline + "number of critical values for Burrow output.";
            JOptionPane.showMessageDialog(this, msg, "Large Burrow Output File",
                                            JOptionPane.ERROR_MESSAGE);
            return false;
        } else if (burrInGB > burrWarn || warning) {
            msg += "Size of Burrow output is quite large. " + newline
                    + "Click OK to allow creating Burrow Output File," + newline
                    + "Cancel to go back to adjust numbers of populations"
                    + newline + "and critical values to decrease the size.";
            int k = JOptionPane.showConfirmDialog(this,
                                msg, "Large Burrow Output File",
                                JOptionPane.OK_CANCEL_OPTION);
            if (k != 0) return false;
        }
        return true;
    }

// =========================================================================

    private String displayGeneration(String generations,
                                    int plan, boolean toShow) {
        String showMe = "";
        String display = "";    // to display generation sets
        if (generations.length() > 0) {
            String genSet[] = getGenerations(generations, plan);
            // each string genSet[] is already trimmed, and only one blank
            // between tokens (all tokens are numbers).
            int lineTp = genSet.length;
            if (genSet[0].charAt(0) == 'E') {
                if (toShow) showMe += genSet[0];
            } else {    // genSet[] is good, genereration set 1 is genSet[0]
                if (toShow)
                    showMe += "From entries for generation sets: " + newline;
                int nGens = 0;
                String setCurr = "";
                String popCurr = "";
                String genCurr = "";
                for (int i = 0; i < lineTp; i++) {
                    if (i < lineTp-1) nGens += (getNumTokens(genSet[i]) - 1);
                    if (genSet[i].equals(setCurr)) {
                        display += "/:";
                        continue;
                    }
                    // note that there is only one blank between 2 tokens
                    // the first blank separates N and generations
                    int j = genSet[i].indexOf(' ');
                    String pop = genSet[i].substring(0, j);
                    String generation = genSet[i].substring(j+1);
                    // Since genSet[i] is not setCurr, cannot have both
                    // pop = popCurr and generation = genCurr.
                    // For plan II, pop is always 0; so in this case,
                    // we will not compare pop and popCurr (popCurr is ignored).
                    if (i > 0) display += "/";
                    if (plan == 0 && (!pop.equals(popCurr))) {
                        display += pop + ":";
                        popCurr = pop;  // for comparing with the next set
                    }
                    if (!generation.equals(genCurr)) {
                        genCurr = generation;
                        generation = generation.replace(' ', ',');
                        display += generation;
                    }
                    setCurr = genSet[i];
                }
            // now, simplify display:
                boolean simplify = true;
                while (simplify) {
                    int n = display.length();
                    if (n > 2 && display.substring(n-2, n).equals("/:")) {
                        display = display.substring(0, n-2);
                    } else simplify = false;
                }
                if (toShow) {
                    String genShow = genSet[lineTp-1];
                    int j = genShow.indexOf(' ');
                    String pop = genShow.substring(0, j);
                    String generation = genShow.substring(j+1);
                    generation = generation.replace(' ', ',');
                    if (plan == 0) genShow = pop + ":" + generation;
                    else genShow = generation;
                    if (lineTp > 1) {
                        showMe += nGens + " generations in ";
                        if (lineTp > 2) showMe += (lineTp-1) +
                            " sets correspond to " + nGens +
                            " 'samples'" + " of " + (lineTp-1) +
                            " 'populations.'" + newline +
                            "Last Set '" + genShow + "' applies" +
                            " to the rest, from 'sample' " + (nGens + 1) + ".";
                        else showMe += "the first set correspond to " + nGens +
                            " 'samples'" + " of population 1." + newline
                            + "Second set applies to the rest, from 'sample' "
                            + (nGens + 1) + ".";
                    } else showMe += "Generation Set '" + genShow +
                                "' applies to the whole input file";
                    if (display.length() < generations.length()) {
                        showMe += newline +
                            "The entries in the textbox have been truncated.";
                        jTextTemp.setText(display);
                    }
                }
            }
        }
        if (toShow) {
            showMe = getInstruct() + newline + newline +  showMe;
// Choose which control on the form to center the dialog box:
//            JOptionPane.showMessageDialog(this, showMe,
//            JOptionPane.showMessageDialog(jTextOutFolder, showMe,
//            JOptionPane.showMessageDialog(jCheckAppend, showMe,
            JOptionPane.showMessageDialog(jCheckName, showMe,
                "Guide for Generation Sets", JOptionPane.INFORMATION_MESSAGE);
        }
        return display;
    }
// =========================================================================
    private boolean getIcon() {
        String aboutFile = currPath + File.separator + aboutLoc;
        if (fileExisted(aboutFile)) {
            iconAbout = new ImageIcon(aboutFile);
            return true;
        }
        return false;
    }
// =========================================================================
    private void makeParamFile() {
        if (!hasInputOutput()) return;
        // check if this is a text file (but not checking if the format is OK):
        String fileName = getFile(jComboBoxFile);
        String path = jTextInpFolder.getText().trim();
        if (currPath.equals(path) && samePath) path = "";
        else path += File.separatorChar;
//        if (checkInp(path+fileName, false) != 0) {
//            String msg = "Input is not a text file.";
        String line1 = getFirstLineAtFile(path+fileName);
        if (line1.length() > 0 && line1.charAt(0) == '1') {
            String msg = "Input is not valid, likely not a text file.";
            JOptionPane.showMessageDialog(this, msg);
            return;
        }
        // check if file is in correct format:
        String msg = checkFormat(path, fileName, jRadioButtonGen.isSelected());
        char c = msg.charAt(0);
        if (c != '0') {
            // remove the first character (which indicates type of error):
            msg = msg.substring(1);
            msg += " Click Cancel to quit.";
            int k = JOptionPane.showConfirmDialog(this,
                                msg, "Input Format Error",
                                JOptionPane.OK_CANCEL_OPTION);
            if (k != 0) return;
            if (c == '1') { // change format
                if (jRadioButtonGen.isSelected())
                    jRadioButtonFstat.setSelected(true);
                else jRadioButtonGen.setSelected(true);
            }
        }
        // check if entries on the form are good:
        if (!goodEntries()) return;
        hasOpt = hasOption();
        if (hasOpt) {
        // numLoci, numPop are known from the call checkFormat
            if (!acceptBurrSize(numLoci, numPop, maxPopBur)) return;
        }
        if (confirmParam(infoParam, optParam))
            createParam(infoParam, optParam);
    }
    
// =========================================================================
    private void openTerminal() {
        if (osName.equals("Windows")) {
            try {
                Runtime.getRuntime().exec("cmd /c start",
                                        null, new File(currPath));
            } catch (Exception e){
//                return;
            }
        } else if (osName.equals("Mac")) {
            try {
                String xterm = xterMac();
                if (xterm.length() > 0)
                    Runtime.getRuntime().exec(xterm, null, new File(currPath));
                else {
                    String msg = "Terminal 'xterm' is not found under " +
                                "known paths in your system!";
                    JOptionPane.showMessageDialog(this, msg);
                }
            } catch (Exception e){  // dialog box message from Mac pops up
//                return;
            }
        } else if (osName.equals("Linux")) {
            try {
// these don't work:
//                Runtime.getRuntime().exec("sh -c");
//                Runtime.getRuntime().exec("xterm cd "+currPath);
//                Runtime.getRuntime().exec("bash");
//                Runtime.getRuntime().exec("bash-i");
// this works, but the shell opens at probably root:
//                Runtime.getRuntime().exec("xterm");
                Runtime.getRuntime().exec("xterm", null, new File(currPath));
            } catch (Exception e){
//                return;
            }
        }
    }

// =========================================================================
    // DP Added 03 May 2013
public class SimpleAboutDialog extends JDialog {
    public SimpleAboutDialog(JFrame parent,ImageIcon icon) {
//    public SimpleAboutDialog(JFrame parent) {
        super(parent, "About", true);

//        ImageIcon icon = new ImageIcon("images/About.png");
// either cite the whole path name or just the name starting from the
// current directory:
//        String aboutFile = aboutLoc;

//        String aboutFile = currPath + File.separator + aboutLoc;
//        ImageIcon icon = new ImageIcon(aboutFile);
        JLabel label1 = new JLabel(icon,JLabel.CENTER);

        label1.setLayout( new BoxLayout(label1, BoxLayout.Y_AXIS) );
        getContentPane().add(label1, "Center");

        JPanel p2 = new JPanel();
        JButton ok = new JButton("OK");
        p2.add(ok);
        getContentPane().add(p2, "South");

        ok.addActionListener(new ActionListener() {
                                public void actionPerformed(ActionEvent evt) {
                                    setVisible(false); } }
                            );


        setSize(400, 300);


    }
}
// =========================================================================
    // DP Added 03 May 2013
    private void launchAbout(){
//*
        if ((!hasImage) && (!fileExisted(currPath, aboutLoc)))
        {
            String msg = version + newline
                    + "Reimplementation of software for the estimation"+ newline
                    + "of comtemporary effective population size (Ne)" + newline
                    + "from genetic data. [Molecular Ecology Resources]";
            JOptionPane.showMessageDialog(this, msg, "About",
                                        JOptionPane.INFORMATION_MESSAGE);
            return;
        }
// Passed the preceding condition, one (or both) of the following must be true:
//      (1) hasImage = true (image from an png file was captured to iconAbout)
//      (2) there is image file with path name specified.
// In case there is no more image file (e.g. deleted), then (1) is true,
// we still want to use old image stored in iconAbout, hasImage unchanged.
// In case there is image file, make new icon with this image file.
//
// If calling getIcon without condition on existence of the image file, and
// if the file does not exist, then hasImage takes false value.
// Then at this time, the old image is still used, but at next call of
// this method, hasImage = false and no image file, preceding "if" will kick in
        if (fileExisted(currPath, aboutLoc)) hasImage = getIcon();

//*/
//        JDialog f = new SimpleAboutDialog(new JFrame());
        JDialog f = new SimpleAboutDialog(new JFrame(), iconAbout);
        f.setResizable(false);
        f.setLocationRelativeTo(this);
//    f.show(); // this method is deprecated
        f.setVisible(true);

    }

// =========================================================================

    // DP Added 03 May 2013
    private void launchHelp(){
        String helpFile = currPath + File.separator + helpLoc;
        try {
            java.net.URI uri = new File(helpFile).toURI();
//                new File(System.getProperty("user.dir")+"/Help/help.htm").toURI();
            desktop.browse(uri);
        } catch (Exception e){
            String msg1 = helpFile + newline + "does not exist.";
//            String msg2 = "Error opening help" + newline +e.getMessage();
            String msg2 = "Error opening help:" + newline + msg1;
            JOptionPane.showMessageDialog(this, msg2);
        }

    }

// =========================================================================


}
